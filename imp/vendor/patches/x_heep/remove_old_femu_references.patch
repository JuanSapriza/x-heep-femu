diff --git a/.gitignore b/.gitignore
index 5720e22..cec871b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -12,10 +12,6 @@ build/
 # ignore apps output file
 run_verif_rtl_log.txt
 
-#ignore femu generated hw
-linux_femu/rtl/linux_femu.sv
-.venv/
-
 # ignore the following hw automatically generated files
 core-v-mini-mcu.upf
 tb/tb_util.svh
diff --git a/Makefile b/Makefile
index 0ec8f40..e69db08 100644
--- a/Makefile
+++ b/Makefile
@@ -18,10 +18,6 @@ TARGET ?= sim
 MCU_CFG ?= mcu_cfg.hjson
 PAD_CFG ?= pad_cfg.hjson
 
-linux-femu-gen: mcu-gen
-	$(PYTHON) util/mcu_gen.py --cfg $(MCU_CFG) --pads_cfg $(PAD_CFG) --outdir linux_femu/rtl/ --tpl-sv linux_femu/rtl/linux_femu.sv.tpl
-	$(MAKE) verible
-
 # Generates mcu files
 mcu-gen: |venv
 	$(PYTHON) util/mcu_gen.py --cfg $(MCU_CFG) --pads_cfg $(PAD_CFG) --outdir hw/core-v-mini-mcu/include --cpu $(CPU) --bus $(BUS) --memorybanks $(MEMORY_BANKS) --external_domains $(EXTERNAL_DOMAINS) --pkg-sv hw/core-v-mini-mcu/include/core_v_mini_mcu_pkg.sv.tpl
diff --git a/README.md b/README.md
index 4a31f17..607a046 100644
--- a/README.md
+++ b/README.md
@@ -339,13 +339,6 @@ to load the binaries with the HS2 cable over JTAG,
 or follow the [ExecuteFromFlash](./ExecuteFromFlash.md)
 guide if you have a FLASH attached to the FPGA.
 
-### Linux-FEMU (Linux Fpga EMUlation)
-
-In this version, the X-HEEP architecture is implemented on the programmable logic (PL) side of the FPGA and Linux is run on the ARM-based processing system (PS) side of the same chip.
-
-Read the [following](./linux_femu/README.md) documentation to have more information about this implementation.
-
-
 # ASIC Implementation
 
 This project can be implemented using standard cells based ASIC flow.
diff --git a/core-v-mini-mcu.core b/core-v-mini-mcu.core
index 10bc150..7150119 100644
--- a/core-v-mini-mcu.core
+++ b/core-v-mini-mcu.core
@@ -105,16 +105,6 @@ filesets:
     - hw/fpga/pad_cell_bypass_input_xilinx.sv:  { file_type: systemVerilogSource }
     - hw/fpga/pad_cell_bypass_output_xilinx.sv:  { file_type: systemVerilogSource }
 
-  fpga-arm-emulation:
-    depend:
-    - pulp-platform.org::axi_spi_slave
-    files:
-    - linux_femu/scripts/xilinx_generate_processing_system.tcl: {file_type: tclSource}
-    - linux_femu/rtl/axi_address_hijacker.v: {file_type: verilogSource}
-    - linux_femu/rtl/linux_femu.sv: {file_type: systemVerilogSource}
-    - linux_femu/constraints/pin_assign.xdc: {file_type: xdc}
-    - linux_femu/constraints/constraints.xdc: {file_type: xdc}
-
   ip-asic:
     depend:
     - technology::prim_mytech
@@ -358,24 +348,6 @@ targets:
         part: xc7z020clg400-1
     toplevel: [xilinx_core_v_mini_mcu_wrapper]
 
-  pynq-z2-arm-emulation:
-    <<: *default_target
-    default_tool: vivado
-    description: TUL Pynq-Z2 Board
-    filesets_append:
-    - x_heep_system
-    - rtl-fpga
-    - ip-fpga
-    - fpga-arm-emulation
-    parameters:
-    - PULP_XPULP=0
-    - SYNTHESIS=true
-    tools:
-      vivado:
-        part: xc7z020clg400-1
-        jobs: 4
-    toplevel: [linux_femu]
-
   sim_nexys_netlist:
     filesets:
     - netlist-fpga
diff --git a/hw/vendor/pulp_platform_gpio.core b/hw/vendor/pulp_platform_gpio.core
index 630f318..d1adbeb 100644
--- a/hw/vendor/pulp_platform_gpio.core
+++ b/hw/vendor/pulp_platform_gpio.core
@@ -43,4 +43,4 @@ targets:
     - target_asic_yosys_synthesis? (clock-gate)
     - target_nexys-a7-100t? (no-clock-gate)
     - target_pynq-z2? (no-clock-gate)
-    - target_pynq-z2-arm-emulation? (no-clock-gate)
+    - target_femu? (no-clock-gate)
diff --git a/linux_femu/README.md b/linux_femu/README.md
deleted file mode 100644
index 45764e7..0000000
--- a/linux_femu/README.md
+++ /dev/null
@@ -1,171 +0,0 @@
-# Linux-FEMU
-
-In this version, the X-HEEP architecture is implemented on the programmable logic (PL) side of the Zynq 7020 chip and Linux is run on the ARM-based processing system (PS) side of the same chip. The X-HEEP JTAG signals are driven by the PS GPIO peripheral and are used to program and debug the architecture, while the X-HEEP UART is connected to the PS UART peripheral and is used to get the stdout of the program running on the architecture. Moreover, the X-HEEP flash SPI is connected to the ARM AXI bus passing through an SPI to AXI bridge: this allows virtualising the flash memory into the on-board DDR RAM memory. In this way, the program running on the architecture can read the external virtualised flash as it was a real flash memory, i.e., this virtualisation is totally transparent to the X-HEEP code.
-
-Go through the following steps to build and use our Linux-FEMU version.
-
-## Build the platform
-
-Start in the x-heep main folder.
-
-## Generate the files
-
-1. Activate the conda environment with:
-
-```
-conda activate core-v-mini-mcu
-```
-
-2. Generate the hdl files by calling:
-
-```
-make linux-femu-gen PAD_CFG=linux_femu/pad_cfg.hjson
-```
-
-__NOTE__: you can customize the mcu-gen process by providing the MEMORY_BANKS - CPU - BUS parameters to the above command.
-
-## Flash the SD card with a Linux image
-
-1. Download the Linux image (version v3.0.1) using the following link:
-
-`http://www.pynq.io/board.html`
-
-2. Follow the procedure explained in the following linked page to flash the downloaded image to the SD card:
-
-`https://pynq.readthedocs.io/en/v2.2.1/appendix.html#writing-the-sd-card`
-
-3. Insert the SD into the Pynq-Z2 board and make sure the booting bridge is on the SD position.
-
-4. Power-on the board and wait for Linux to boot (a row of 4 leds should turn on).
-
-## Create the Vivado project and generate the bitstream
-
-1. Starting in the x-heep main folder, run the following command to create the Vivado project and generate the bitstream:
-
-```
-make vivado-fpga FPGA_BOARD=pynq-z2-arm-emulation
-```
-
-2. Open the project x-heep/build/openhwgroup.org_systems_core-v-mini-mcu_0/pynq-z2-arm-emulation-vivado/openhwgroup.org_systems_core-v-mini-mcu_0.xpr with Vivado and use the Hardware Manager to program the bitstream to the Zynq 7020 of the Pynq-Z2 board.
-
-## Connect to Linux running on the Pynq-Z2 board
-
-Connect your Linux-based PC to the Pynq-Z2 board through Ethernet and run the following command:
-
-```
-ssh -X xilinx@board_ip
-```
-
-The default password is: xilinx
-
-If you need additional documentation on how to connect your PC to the Pynq-Z2 board, use the following link:
-
-`https://pynq.readthedocs.io/en/v2.6.1/getting_started/pynq_z2_setup.html`
-
-## Install OpenOCD on the Pynq-Z2 board
-
-1. Clone the OpenOCD repository usign the following link:
-
-`https://github.com/openocd-org/openocd`
-
-2. Run the following commands from the OpneOCD main folder to install it:
-
-```
-sudo ./bootstrap
-sudo ./configure --enable-sysfsgpio
-sudo make
-sudo make install
-```
-
-## Copy the x-heep folder to the Pynq-Z2 baord
-
-Copy the x-heep/linux_femu/arm/ folder from your PC to the home directory of the Pynq-Z2 board with the following command:
-
-```
-sudo scp -r x-heep/linux_femu/arm/ xilinx@board_ip:~
-```
-
-## Enable UART1 on Linux on the Pynq-Z2 baord
-
-Enter the arm/uart_enable/ folder and run the following commands:
-
-```
-sudo su
-mkdir -p /configfs
-./uart_enable.sh
-exit
-```
-
-These commands enable the UART1 on the ARM system side of the Zynq 7020 on the Pynq-Z2 board. UART1 is used to receive the stdout of the code running on the HEEP architecture implemented on the PL side of the chip.
-
-## Prepare the needed shells
-
-You need to use 5 shells (the first, second and third shells will run on the Pynq-Z2 board, while the fourth and fifth shells will run on your PC):
-
-1. First shell - run virtual flash app on the Pynq-Z2 board - browse to the arm/virtual_flash/ folder and execute the following commands to compile and run the required application:
-
-```
-sudo make clean
-sudo make
-sudo ./virtual_flash
-```
-
-This app allocates a buffer into the off-chip DDR memory of the Pynq-Z2 board and stores its physical base address to the hijacker PL peripheral.
-
-2. Second shell - run the following commands on the Pynq-Z2 board to get the stdout from the app running on x-heep:
-
-```
-sudo apt-get install screen
-sudo screen /dev/ttyPS1 115200
-```
-
-3. Third shell - run openocd on the Pynq-Z2 board - browse to the arm/openocd_cfg/ folder and run the following command:
-
-```
-sudo openocd -f ./gpio_bitbang.cfg
-```
-
-4. Fourth shell - compile HEEP app on your PC - browse to the x-heep/sw/ folder and run the following command:
-
-```
-make clean applications/example_virtual_flash/example_virtual_flash.hex TARGET=pynq-z2
-```
-
-With this command you compile a sample RISC-V based application that uses the allocated DDR-based virtual memory. You may want to change this command with the name of your own application.
-
-5. Fifth shell - run GDB on your PC - browse to the x-heep/sw/applications/example_virtual_flash/ folder and run the following command to connect GDB:
-
-```
-sudo /path_to_your_riscv_toolchain/bin/riscv32-unknown-elf-gdb
-```
-
-Use the following GDB commands to connect to OpenOCD running on the Pynq-Z2 board and run your application:
-
-```
-(gdb) target remote board_ip:3333
-(gdb) load example_virtual_flash.elf
-(gdb) cont
-```
-
-Go back to the first shell and press ENTER to end the application and dump the content of the virtual flash to a file. Then, run the following commands:
-
-```
-xxd dump.txt dump
-nano dump
-```
-
-Check if your result corresponds to the following lines:
-
-```
-00000000: 0000 0000 0000 0001 0000 0002 0000 0003  ................
-00000010: 0000 0004 0000 0005 0000 0006 0000 0007  ................
-00000020: 0000 0008 0000 0009 0000 000a 0000 000b  ................
-00000030: 0000 000c 0000 000d 0000 000e 0000 000f  ................
-00000040: 0000 0010 0000 0011 0000 0012 0000 0013  ................
-00000050: 0000 0014 0000 0015 0000 0016 0000 0017  ................
-00000060: 0000 0018 0000 0019 0000 001a 0000 001b  ................
-00000070: 0000 001c 0000 001d 0000 001e 0000 001f  ................
-00000080: 0000 0000 0000 0000 0000 0000 0000 0000  ................
-```
-
-__NOTE__: to run other applications, press the hard reset button on the Pynq-Z2 board (BTN3) and re-connect OpneOCD and GDB.
diff --git a/linux_femu/arm/openocd_cfg/README.md b/linux_femu/arm/openocd_cfg/README.md
deleted file mode 100644
index 38dfdbc..0000000
--- a/linux_femu/arm/openocd_cfg/README.md
+++ /dev/null
@@ -1,80 +0,0 @@
-### Hardware Configurations
-
-On the hardware side, we must configure the ZYNQ processing system to use the EMIO and export them externally so that they can be attached to x-heep. They are then routed outwards from the wrapper to x-heep JTAG signals.
-
-### Software Configurations
-
-## Target adapter configuration __gpio_bitbang.cfg__:
-
-```
-# SPDX-License-Identifier: GPL-2.0-or-later
-
-#
-# Config for using RaspberryPi's expansion header
-#
-# This is best used with a fast enough buffer but also
-# is suitable for direct connection if the target voltage
-# matches RPi's 3.3V
-#
-# Do not forget the GND connection, pin 6 of the expansion header.
-#
-
-adapter driver sysfsgpio
-transport select jtag
-
-bindto 0.0.0.0
-
-set _CHIPNAME riscv
-jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x10001c05
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME riscv -chain-position $_TARGETNAME -coreid 0x000
-echo "Target created"
-
-riscv set_reset_timeout_sec 2000
-riscv set_command_timeout_sec 2000
-# riscv set_prefer_sba off
-
-echo "Setting preferences"
-
-# Each of the JTAG lines need a gpio number set: tck tms tdi tdo
-# Header pin numbers: 23 22 19 21
-sysfsgpio jtag_nums 964 961 963 962
-
-# Each of the SWD lines need a gpio number set: swclk swdio
-# Header pin numbers: 23 22
-# sysfsgpio swd_nums 11 25
-
-# If you define trst or srst, use appropriate reset_config
-# Header pin numbers: TRST - 26, SRST - 18
-
-sysfsgpio trst_num 960
-reset_config trst_only
-
-# sysfsgpio srst_num 24
-# reset_config srst_only srst_push_pull
-
-# or if you have both connected,
-# reset_config trst_and_srst srst_push_pull
-
-scan_chain
-
-init
-
-echo "Init routine started"
-
-halt
-echo "Ready for connections"
-```
-
-This instructs openocd to use the riscv HART and jtag module but instead of transmitting the commands over the usual FTDI usb adapter, it bitbangs the GPIOs by using the SYSFS framework.
-
-In order to understand the pin numbering used in the script we have to know how the JTAG has been ported to the PYNQ without using external adapters. The ZYNQ 7000 offers several banks of GPIO lines used for different purposes. The first 54 are MIO (multiplexed I/O) and are configured for different purposes but are PS-side only. After those, we have 64 EMIO (extended MIO) which are lines that can be routed to the PL). The idea is therefore to expose 5 EMIO GPIOS (5 jtag signals) and route them to the PL and to x-heep directly. Those can be controlled as normal GPIO lines and allow interfacing directly from ARM.
-
-Therefore, the pin numbers used in the configuration file are derived as follows:
-
-1. Find the GPIO starting numbers that linux uses by running ``` sudo cat /sys/kernel/debug/gpio ``` -> in this case it was __906__
-
-2. Add 54 (the first 54 GPIOS are the MIOs).
-
-3. Add the gpio_n assigned to the specific signal (depends on the HDL connections).
diff --git a/linux_femu/arm/openocd_cfg/gpio_bitbang.cfg b/linux_femu/arm/openocd_cfg/gpio_bitbang.cfg
deleted file mode 100755
index 11c5519..0000000
--- a/linux_femu/arm/openocd_cfg/gpio_bitbang.cfg
+++ /dev/null
@@ -1,58 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-or-later
-
-#
-# Config for using RaspberryPi's expansion header
-#
-# This is best used with a fast enough buffer but also
-# is suitable for direct connection if the target voltage
-# matches RPi's 3.3V
-#
-# Do not forget the GND connection, pin 6 of the expansion header.
-#
-
-adapter driver sysfsgpio
-transport select jtag
-
-bindto 0.0.0.0
-
-set _CHIPNAME riscv
-jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x10001c05
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME riscv -chain-position $_TARGETNAME -coreid 0x000
-echo "Target created"
-
-riscv set_reset_timeout_sec 2000
-riscv set_command_timeout_sec 2000
-# riscv set_prefer_sba off
-
-echo "Setting preferences"
-
-# Each of the JTAG lines need a gpio number set: tck tms tdi tdo
-# Header pin numbers: 23 22 19 21
-sysfsgpio jtag_nums 964 961 963 962
-
-# Each of the SWD lines need a gpio number set: swclk swdio
-# Header pin numbers: 23 22
-# sysfsgpio swd_nums 11 25
-
-# If you define trst or srst, use appropriate reset_config
-# Header pin numbers: TRST - 26, SRST - 18
-
-sysfsgpio trst_num 960
-reset_config trst_only
-
-# sysfsgpio srst_num 24
-# reset_config srst_only srst_push_pull
-
-# or if you have both connected,
-# reset_config trst_and_srst srst_push_pull
-
-scan_chain
-
-init
-
-echo "Init routine started"
-
-halt
-echo "Ready for connections"
diff --git a/linux_femu/arm/uart_enable/README.md b/linux_femu/arm/uart_enable/README.md
deleted file mode 100644
index 15f4fac..0000000
--- a/linux_femu/arm/uart_enable/README.md
+++ /dev/null
@@ -1,57 +0,0 @@
-### Hardware Configurations
-
-On the hardware side, we must configure the ZYNQ processing system to enable UART1 and route tx and rx to the EMIO pins so that they can be attached to x-heep. They are then routed outwards from the wrapper to x-heep UART signals.
-
-__NOTE__: remembed to connect tx to rx and viceversa.
-
-### Software Configurations
-
-## Enable UART1
-
-In order to ask Linux to use that as a normal serial port, we need to modify the DEVICE TREE to expose this new hardware piece. In theory, the UART1 peripheral is already defined in the tree but is disabled. Instead of rebuilding the device tree, we can add an overlay at runtime to add and change configuration properties of the tree. In particular, we need to extend the device tree with the following:
-
-```
-/dts-v1/;
-/plugin/;
-
-/{
-    fragment@0{
-        target-path = "/aliases";
-        __overlay__ {
-            serial1 = "/axi/serial@e0001000";
-        };
-    };
-
-    fragment@1{
-        target = <&uart1>;
-        __overlay__ {
-            status = "okay";
-        };
-    };
-};
-
-```
-
-This first makes an alias to make sure that the uart1 (/axi/serial@e0001000) is called serial1, and then enables it by setting the status as "okay". Aliasing is important to avoid a problem that could arise if the kernel decides to swap the ttyPS1 and ttyPS0 (uart0 and the one used to connect to ARM through serial), because we'd have no access to the board over serial.
-
-1. DTSI file must be compiled into binary format as follows:
-
-```
-dtc -O dtb -o uart_enable.dtbo -b 0 -@ uart_enable.dtsi
-```
-2. We mount the configfs, which is a RAM-based configuration file-system exposed to add overlays.
-
-```
-sudo mount configfs configfs /configfs
-sudo mkdir configfs/device-tree/overlays/uart_enable
-```
-
-3. Concatenate the dtbo binary file to insert into the kernel device tree.
-
-```
-sudo su
-cat uart_enable.dtbo >/configfs/device-tree/overlays/uart_enable/dtbo
-exit
-```
-
-4. Make sure with dmesg that no errors were thrown and that /dev/ttySP1 has appeared -> that is x-heep's serial.
diff --git a/linux_femu/arm/uart_enable/uart_enable.dtbo b/linux_femu/arm/uart_enable/uart_enable.dtbo
deleted file mode 100755
index 896a0f34f64bdb7390b4dc181001e74076428956..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 344
zcmZusJqyAx5WV;@2nq^1xjDH=n@u|PXSjtM(ps#xB&oFj(m&$vq~0~9qWIwD-97G-
zm)q=l2M`AU*pr5&TjGK^Co;HywAJ?^x>h6x)3d&~n709j#0eJx<{4UTxh4puimNs`
zHcD~Nb1ULBz&Z=8HW}uz4#Q9qd4MqJ_<2LNKJSi*%NK$4-`!*K*To4NQbvE5Qb|@<
orS&oT9Gjs3h>RSXRJ-Um$He=)65SDeWC`8_>(EseDl|^Q8(n`scK`qY

diff --git a/linux_femu/arm/uart_enable/uart_enable.dtsi b/linux_femu/arm/uart_enable/uart_enable.dtsi
deleted file mode 100755
index 21804e3..0000000
--- a/linux_femu/arm/uart_enable/uart_enable.dtsi
+++ /dev/null
@@ -1,18 +0,0 @@
-/dts-v1/;
-/plugin/;
-
-/{
-	fragment@0{
-		target-path = "/aliases";
-		__overlay__ {
-			serial1 = "/axi/serial@e0001000";	
-		};
-	};
-
-	fragment@1{
-		target = <&uart1>;
-		__overlay__ {
-			status = "okay";
-		};
-	};
-};
diff --git a/linux_femu/arm/uart_enable/uart_enable.sh b/linux_femu/arm/uart_enable/uart_enable.sh
deleted file mode 100755
index ec02611..0000000
--- a/linux_femu/arm/uart_enable/uart_enable.sh
+++ /dev/null
@@ -1,5 +0,0 @@
-#!/bin/bash
-
-mount -t configfs configfs /configfs
-mkdir /configfs/device-tree/overlays/uart_enable
-cat ./uart_enable.dtbo >/configfs/device-tree/overlays/uart_enable/dtbo
diff --git a/linux_femu/arm/virtual_flash/Makefile b/linux_femu/arm/virtual_flash/Makefile
deleted file mode 100755
index e9c11b6..0000000
--- a/linux_femu/arm/virtual_flash/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-all: virtual_flash
-
-virtual_flash: virtual_flash.cpp OverlayControl.c OverlayControl.h
-	g++ -O0 -g -Wall virtual_flash.cpp OverlayControl.c -o virtual_flash -lpthread -lm -lcma
-
-clean:
-	rm -f virtual_flash
diff --git a/linux_femu/arm/virtual_flash/OverlayControl.c b/linux_femu/arm/virtual_flash/OverlayControl.c
deleted file mode 100755
index 68f2a85..0000000
--- a/linux_femu/arm/virtual_flash/OverlayControl.c
+++ /dev/null
@@ -1,103 +0,0 @@
-
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <sys/mman.h>
-
-// 1 --> Basic logging, 2 --> Debugging
-#define LOGGING 2
-
-#include "OverlayControl.h"
-extern "C" {
-#include <libxlnk_cma.h>
-}
-
-static volatile uint32_t * memMapAddr = NULL;
-static int memMapFileDesc = -1;
-static uint32_t memMapSize = 0;
-
-volatile uint32_t * MapMemIO(uint32_t baseAddr, uint32_t mapSize)
-{
-  bool res = true;
-
-    res = ( (memMapFileDesc = open("/dev/mem", O_RDWR | O_SYNC )) != -1);
-
-    if (!res) {
-    #ifdef LOGGING
-        printf("Error opening file.\n");
-    #endif
-    }
-    else {
-    #if LOGGING == 2
-        printf("File opened.\n");
-    #endif
-        memMapAddr = (volatile unsigned int *)mmap(NULL, mapSize, PROT_READ | PROT_WRITE, MAP_SHARED, memMapFileDesc, baseAddr);
-        res = (memMapAddr != MAP_FAILED);
-        if (!res) {
-      #ifdef LOGGING
-            printf("Memory mapping failed.\n");
-      #endif
-            close(memMapFileDesc);
-            memMapFileDesc = -1;
-      memMapAddr = NULL;
-        }
-    }
-
-    if (res) {
-    #ifdef LOGGING
-        printf("Memory mapped.\n");
-    #endif
-    memMapSize = mapSize;
-  }
-
-    return memMapAddr;
-}
-
-bool UnmapMemIO()
-{
-    bool res = true;
-
-    if ((memMapAddr != NULL) && (memMapAddr != MAP_FAILED)) {
-        if ( munmap((void*)memMapAddr, memMapSize) ) {
-      #ifdef LOGGING
-            printf("Memory unmapping failed.\n");
-      #endif
-            res = false;
-        }
-        else {
-      #ifdef LOGGING
-            printf("Memory unmapped.\n");
-      #endif
-        }
-    }
-
-    if (memMapFileDesc != -1) {
-        close(memMapFileDesc);
-        memMapFileDesc = -1;
-    }
-
-    return res;
-}
-
-// Reference of functions to (de)allocate DMA memory.
-// extern "C" {
-// #include <libxlnk_cma.h>
-// }
-/* * Allocate a physically contiguos chunk of CMA memory and map it into
- * virtual memory space. Return this Virtual pointer. Returns -1 on failure.
-void *cma_alloc(uint32_t len, uint32_t cacheable);
- * Return a physical memory address corresponding to a given Virtual address
- * pointer. Returns NULL on failure.
-unsigned long cma_get_phy_addr(void *buf);
- * Free a previously allocated CMA memory chunk.
-void cma_free(void *buf);
- * Returns the number of available CMA memiry pages which can be allocated.
-uint32_t cma_pages_available();
- * Extra functions in case user needs to flush or invalidate Cache.
-void cma_flush_cache(void *buf, unsigned int phys_addr, int size);
-void cma_invalidate_cache(void *buf, unsigned int phys_addr, int size);
-*/
diff --git a/linux_femu/arm/virtual_flash/OverlayControl.h b/linux_femu/arm/virtual_flash/OverlayControl.h
deleted file mode 100755
index 9280732..0000000
--- a/linux_femu/arm/virtual_flash/OverlayControl.h
+++ /dev/null
@@ -1,27 +0,0 @@
-
-#ifndef	OVERLAYCONTROL_H
-#define	OVERLAYCONTROL_H
-
-volatile uint32_t * MapMemIO(uint32_t baseAddr, uint32_t mapSize);
-bool UnmapMemIO();
-
-// Reference of functions to (de)allocate DMA memory.
-// extern "C" {
-// #include <libxlnk_cma.h>
-// }
-/* * Allocate a physically contiguos chunk of CMA memory and map it into
- * virtual memory space. Return this Virtual pointer. Returns -1 on failure.
-void *cma_alloc(uint32_t len, uint32_t cacheable);
- * Return a physical memory address corresponding to a given Virtual address
- * pointer. Returns NULL on failure.
-unsigned long cma_get_phy_addr(void *buf);
- * Free a previously allocated CMA memory chunk.
-void cma_free(void *buf);
- * Returns the number of available CMA memiry pages which can be allocated.
-uint32_t cma_pages_available();
- * Extra functions in case user needs to flush or invalidate Cache.
-void cma_flush_cache(void *buf, unsigned int phys_addr, int size);
-void cma_invalidate_cache(void *buf, unsigned int phys_addr, int size);
-*/
-
-#endif // OVERLAYCONTROL_H
diff --git a/linux_femu/arm/virtual_flash/virtual_flash.cpp b/linux_femu/arm/virtual_flash/virtual_flash.cpp
deleted file mode 100755
index 8de7bc7..0000000
--- a/linux_femu/arm/virtual_flash/virtual_flash.cpp
+++ /dev/null
@@ -1,100 +0,0 @@
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <time.h>
-#include <unistd.h>
-#include <signal.h>
-#include "OverlayControl.h"
-
-extern "C" {
-#include <libxlnk_cma.h>
-}
-
-const uint32_t MEM_IS_CACHEABLE = 0;
-const uint32_t MAP_SIZE = 64*1024;
-const uint32_t BASE_ADDR = 0x43C00000;
-const uint32_t ALLOC_SIZE_BYTE = 64*1024*128;
-const uint32_t FIXED_VALUE = 0x1c;
-
-uint32_t *virtual_flash_buffer, *virtual_flash_buffer_phy;
-
-static void stop(int)
-{
-    signal(SIGTERM, SIG_DFL);
-    signal(SIGINT, SIG_DFL);
-
-    if(virtual_flash_buffer != NULL){
-        FILE* dump = fopen("./dump.txt", "wb");
-        fwrite(virtual_flash_buffer, ALLOC_SIZE_BYTE, 1, dump);
-        fclose(dump);
-    }
-}
-
-int main(int argc, char **argv)
-{
-    signal(SIGTERM, stop);
-    signal(SIGINT, stop);
-    volatile uint8_t *pl_peripherals = NULL;
-    volatile uint32_t* hijacker = NULL;
-
-    printf("Press ENTER to confirm that the bitstream is loaded (proceeding without it can crash the board).\n");
-    getchar();
-
-    // Get the virtual address corresponding to the physical base address of the PL peripherals
-    if ((pl_peripherals = (uint8_t *) MapMemIO(BASE_ADDR, MAP_SIZE)) == NULL) {
-        printf("Error getting address!\n");
-        return -1;
-    }
-    printf("PL peripherals mapped at 0x%08X.\n", (uint32_t)pl_peripherals);
-    fflush(stdout);
-
-    // Map hijacker PL peripheral
-    hijacker = (uint32_t *)pl_peripherals;
-    printf("hijacker mapped at 0x%08X.\n", (uint32_t)hijacker);
-
-    // Allocate DDR memory buffer to virtualize a Flash memory and get its physical address
-    fflush(stdout);
-    virtual_flash_buffer = (uint32_t *)cma_alloc(ALLOC_SIZE_BYTE, MEM_IS_CACHEABLE);
-    virtual_flash_buffer_phy = (uint32_t *)((uint32_t)cma_get_phy_addr(virtual_flash_buffer));
-    printf("DDR memory buffer allocated.\n");
-    fflush(stdout);
-    printf("Virtual address: 0x%.8X.\n", (uint32_t)virtual_flash_buffer);
-    fflush(stdout);
-    printf("Physical address: Phys: 0x%.8X.\n\n", (uint32_t)virtual_flash_buffer_phy);
-    fflush(stdout);
-    if (virtual_flash_buffer == NULL) {
-        printf("Error allocating DDR memory for %u bytes!\n", ALLOC_SIZE_BYTE);
-        return -1;
-    }
-
-    // Initialize DDR memory buffer
-    for (uint32_t i = 0; i < ALLOC_SIZE_BYTE / sizeof(uint32_t); i++)
-        virtual_flash_buffer[0] = i;
-
-    // Copy the physical address of the DDR memory buffer to hijacker PL peripheral
-    *hijacker = (uint32_t)virtual_flash_buffer_phy;
-
-    // Press ENTER to end the application
-    printf("Press ENTER to end the application.\n");
-    getchar();
-
-    printf("Virtual flash read and content stored in file dump.txt.\n\n");
-
-    // Read content of the DDR memory buffer and store it to a file
-    FILE *dump = fopen("./dump.txt", "wb");
-    fwrite(virtual_flash_buffer, ALLOC_SIZE_BYTE, 1, dump);
-    fclose(dump);
-
-    ///////////////////////////////////////////////////////////////////////////////////////
-    // DDR memory is a global variable. In this Linux version, it is allocated
-    // by a pl_peripherals driver provided by Xilinx. This means that it is not freed
-    // automatically when our process exits. We MUST free it or the board will
-    // run out of DMA memory!!!
-    ///////////////////////////////////////////////////////////////////////////////////////
-    if (virtual_flash_buffer != NULL)
-        cma_free(virtual_flash_buffer);
-    UnmapMemIO();
-
-    return 0;
-}
diff --git a/linux_femu/constraints/constraints.xdc b/linux_femu/constraints/constraints.xdc
deleted file mode 100644
index ca9babe..0000000
--- a/linux_femu/constraints/constraints.xdc
+++ /dev/null
@@ -1 +0,0 @@
-set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets linux_femu/pad_ring_i/pad_clk_i/xilinx_iobuf_i/O]
diff --git a/linux_femu/constraints/pin_assign.xdc b/linux_femu/constraints/pin_assign.xdc
deleted file mode 100644
index d6be7e8..0000000
--- a/linux_femu/constraints/pin_assign.xdc
+++ /dev/null
@@ -1,73 +0,0 @@
-# Copyright 2022 EPFL
-# Solderpad Hardware License, Version 2.1, see LICENSE.md for details.
-# SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1
-
-set_property -dict {PACKAGE_PIN H16 IOSTANDARD LVCMOS33} [get_ports clk_in]
-set_property -dict {PACKAGE_PIN L19 IOSTANDARD LVCMOS33} [get_ports rst_i]
-set_property -dict {PACKAGE_PIN M14 IOSTANDARD LVCMOS33} [get_ports rst_led]
-set_property -dict {PACKAGE_PIN N16 IOSTANDARD LVCMOS33} [get_ports clk_led]
-set_property -dict {PACKAGE_PIN W9 IOSTANDARD LVCMOS33} [get_ports clk_out]
-set_property -dict {PACKAGE_PIN R14 IOSTANDARD LVCMOS33} [get_ports exit_valid_o]
-set_property -dict {PACKAGE_PIN P14 IOSTANDARD LVCMOS33} [get_ports exit_value_o]
-set_property -dict {PACKAGE_PIN M19 IOSTANDARD LVCMOS33} [get_ports execute_from_flash_i]
-set_property -dict {PACKAGE_PIN M20 IOSTANDARD LVCMOS33} [get_ports boot_select_i]
-
-## Pmoda
-## RPi GPIO 7-0 are shared with pmoda_rpi_gpio_tri_io[7:0]
-
-# QSPI
-
-set_property -dict {PACKAGE_PIN F16 IOSTANDARD LVCMOS33} [get_ports spi_csb_io]
-set_property -dict {PACKAGE_PIN H15 IOSTANDARD LVCMOS33} [get_ports spi_sck_io]
-set_property -dict {PACKAGE_PIN T12 IOSTANDARD LVCMOS33} [get_ports {spi_sd_0_io}]
-set_property -dict {PACKAGE_PIN W15 IOSTANDARD LVCMOS33} [get_ports {spi_sd_1_io}]
-set_property -dict {PACKAGE_PIN P18 IOSTANDARD LVCMOS33} [get_ports {spi_sd_2_io}]
-set_property -dict {PACKAGE_PIN N17 IOSTANDARD LVCMOS33} [get_ports {spi_sd_3_io}]
-
-## Pmodb
-
-set_property -dict {PACKAGE_PIN T14 IOSTANDARD LVCMOS33} [get_ports {gpio_io[0]}]
-set_property -dict {PACKAGE_PIN Y8 IOSTANDARD LVCMOS33} [get_ports {gpio_io[1]}]
-set_property -dict {PACKAGE_PIN W8 IOSTANDARD LVCMOS33} [get_ports {gpio_io[2]}]
-set_property -dict {PACKAGE_PIN Y7 IOSTANDARD LVCMOS33} [get_ports {gpio_io[3]}]
-set_property -dict {PACKAGE_PIN Y6 IOSTANDARD LVCMOS33} [get_ports {gpio_io[4]}]
-set_property -dict {PACKAGE_PIN U12 IOSTANDARD LVCMOS33} [get_ports {gpio_io[5]}]
-set_property -dict {PACKAGE_PIN W10 IOSTANDARD LVCMOS33} [get_ports {gpio_io[6]}]
-set_property -dict {PACKAGE_PIN V10 IOSTANDARD LVCMOS33} [get_ports {gpio_io[7]}]
-set_property -dict {PACKAGE_PIN V8 IOSTANDARD LVCMOS33} [get_ports {gpio_io[8]}]
-set_property -dict {PACKAGE_PIN U8 IOSTANDARD LVCMOS33} [get_ports {gpio_io[9]}]
-set_property -dict {PACKAGE_PIN V7 IOSTANDARD LVCMOS33} [get_ports {gpio_io[10]}]
-set_property -dict {PACKAGE_PIN U7 IOSTANDARD LVCMOS33} [get_ports {gpio_io[11]}]
-set_property -dict {PACKAGE_PIN V6 IOSTANDARD LVCMOS33} [get_ports {gpio_io[12]}]
-set_property -dict {PACKAGE_PIN U13 IOSTANDARD LVCMOS33} [get_ports {gpio_io[13]}]
-set_property -dict {PACKAGE_PIN V13 IOSTANDARD LVCMOS33} [get_ports {gpio_io[14]}]
-set_property -dict {PACKAGE_PIN Y9 IOSTANDARD LVCMOS33} [get_ports {gpio_io[15]}]
-set_property -dict {PACKAGE_PIN A20 IOSTANDARD LVCMOS33} [get_ports {gpio_io[16]}]
-set_property -dict {PACKAGE_PIN B19 IOSTANDARD LVCMOS33} [get_ports {gpio_io[17]}]
-set_property -dict {PACKAGE_PIN B20 IOSTANDARD LVCMOS33} [get_ports {gpio_io[18]}]
-set_property -dict {PACKAGE_PIN P15 IOSTANDARD LVCMOS33} [get_ports {gpio_io[19]}]
-set_property -dict {PACKAGE_PIN F20 IOSTANDARD LVCMOS33} [get_ports {gpio_io[20]}]
-set_property -dict {PACKAGE_PIN F19 IOSTANDARD LVCMOS33} [get_ports {gpio_io[21]}]
-set_property -dict {PACKAGE_PIN P16 IOSTANDARD LVCMOS33} [get_ports {gpio_io[22]}]
-set_property -dict {PACKAGE_PIN W6 IOSTANDARD LVCMOS33} [get_ports {spi2_csb_io[0]}]
-set_property -dict {PACKAGE_PIN T15 IOSTANDARD LVCMOS33} [get_ports {spi2_csb_io[1]}]
-set_property -dict {PACKAGE_PIN C20 IOSTANDARD LVCMOS33} [get_ports {spi2_sck_io}]
-set_property -dict {PACKAGE_PIN V17 IOSTANDARD LVCMOS33} [get_ports {spi2_sd_0_io}]
-set_property -dict {PACKAGE_PIN V18 IOSTANDARD LVCMOS33} [get_ports {spi2_sd_1_io}]
-set_property -dict {PACKAGE_PIN T16 IOSTANDARD LVCMOS33} [get_ports {spi2_sd_2_io}]
-set_property -dict {PACKAGE_PIN R17 IOSTANDARD LVCMOS33} [get_ports {spi2_sd_3_io}]
-#set_property -dict {PACKAGE_PIN W6 IOSTANDARD LVCMOS33} [get_ports {gpio_io[24]}]
-#set_property -dict {PACKAGE_PIN C20 IOSTANDARD LVCMOS33} [get_ports {gpio_io[25]}]
-#set_property -dict {PACKAGE_PIN V17 IOSTANDARD LVCMOS33} [get_ports {gpio_io[26]}]
-#set_property -dict {PACKAGE_PIN V18 IOSTANDARD LVCMOS33} [get_ports {gpio_io[27]}]
-#set_property -dict {PACKAGE_PIN T16 IOSTANDARD LVCMOS33} [get_ports {gpio_io[28]}]
-#set_property -dict {PACKAGE_PIN R17 IOSTANDARD LVCMOS33} [get_ports {gpio_io[29]}]
-#set_property -dict {PACKAGE_PIN V15 IOSTANDARD LVCMOS33} [get_ports {gpio_io[30]}]
-#set_property -dict {PACKAGE_PIN D19 IOSTANDARD LVCMOS33} [get_ports {gpio_io[31]}]
-
-set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets jtag_tck_i_IBUF]
-
-set_property PACKAGE_PIN W13 [get_ports i2c_scl_io]
-set_property PACKAGE_PIN T10 [get_ports i2c_sda_io]
-set_property IOSTANDARD LVCMOS33 [get_ports i2c_scl_io]
-set_property IOSTANDARD LVCMOS33 [get_ports i2c_sda_io]
diff --git a/linux_femu/pad_cfg.hjson b/linux_femu/pad_cfg.hjson
deleted file mode 100644
index 235ee13..0000000
--- a/linux_femu/pad_cfg.hjson
+++ /dev/null
@@ -1,208 +0,0 @@
-// Copyright 2020 ETH Zurich and University of Bologna.
-// Solderpad Hardware License, Version 0.51, see LICENSE for details.
-// SPDX-License-Identifier: SHL-0.51
-// Derived from Occamy: https://github.com/pulp-platform/snitch/blob/master/hw/system/occamy/src/occamy_cfg.hjson
-// Peripherals configuration for core-v-mini-mcu.
-{
-    pads: {
-
-        clk: {
-            num: 1,
-            type: input
-        },
-        rst: {
-            num: 1,
-            active: low,
-            driven_manually: True
-            type: input
-        },
-        boot_select: {
-            num: 1,
-            type: input
-        },
-        execute_from_flash: {
-            num: 1,
-            type: input
-        },
-        jtag_tck: {
-            num: 1,
-            keep_internal: True
-            type: input
-        },
-        jtag_tms: {
-            num: 1,
-            keep_internal: True
-            type: input
-        },
-        jtag_trst: {
-            num: 1,
-            keep_internal: True
-            active: low,
-            type: input
-        },
-        jtag_tdi: {
-            num: 1,
-            keep_internal: True
-            type: input
-        },
-        jtag_tdo: {
-            num: 1,
-            keep_internal: True
-            type: output
-        },
-        uart_rx: {
-            num: 1,
-            keep_internal: True
-            type: input
-        },
-        uart_tx: {
-            num: 1,
-            keep_internal: True
-            type: output
-        },
-        exit_valid: {
-            num: 1,
-            type: output
-        },
-        gpio: {
-            num: 23,
-            num_offset: 0, #first gpio is gpio0
-            type: inout
-        },
-        spi_flash_sck: {
-            num: 1,
-            keep_internal: True
-            type: inout
-        },
-        spi_flash_cs: {
-            num: 2, #carefull, the x-heep uses the CS from the spi pkg, change it
-            keep_internal: True
-            type: inout
-        },
-        spi_flash_sd: {
-            num: 4,
-            keep_internal: True
-            type: inout
-        },
-        spi_sck: {
-            num: 1,
-            type: inout
-        },
-        spi_cs: {
-            num: 2,
-            type: inout
-        },
-        spi_sd: {
-            num: 4,
-            type: inout
-        },
-        spi2_cs_0: {
-            num: 1,
-            type: inout
-            mux: {
-                spi2_cs_0: {
-                    type: inout
-                },
-                gpio_23: {
-                    type: inout
-                },
-            }
-        },
-        spi2_cs_1: {
-            num: 1,
-            type: inout
-            mux: {
-                spi2_cs_1: {
-                    type: inout
-                },
-                gpio_24: {
-                    type: inout
-                },
-            },
-        },
-        spi2_sck: {
-            num: 1,
-            type: inout
-            mux: {
-                spi2_sck: {
-                    type: inout
-                },
-                gpio_25: {
-                    type: inout
-                },
-            }
-        },
-        spi2_sd_0: {
-            num: 1,
-            type: inout
-            mux: {
-                spi2_sd_0: {
-                    type: inout
-                },
-                gpio_26: {
-                    type: inout
-                },
-            }
-        },
-        spi2_sd_1: {
-            num: 1,
-            type: inout
-            mux: {
-                spi2_sd_1: {
-                    type: inout
-                },
-                gpio_27: {
-                    type: inout
-                },
-            }
-        },
-        spi2_sd_2: {
-            num: 1,
-            type: inout
-            mux: {
-                spi2_sd_2: {
-                    type: inout
-                },
-                gpio_28: {
-                    type: inout
-                },
-            }
-        },
-        spi2_sd_3: {
-            num: 1,
-            type: inout
-            mux: {
-                spi2_sd_3: {
-                    type: inout
-                },
-                gpio_29: {
-                    type: inout
-                },
-            }
-        },
-        i2c_scl: {
-            num: 1,
-            type: inout
-            mux: {
-                i2c_scl: {
-                    type: inout
-                },
-                gpio_31: {
-                    type: inout
-                },
-            }
-        },
-        i2c_sda: {
-            num: 1,
-            type: inout
-            mux: {
-                i2c_sda: {
-                    type: inout
-                },
-                gpio_30: {
-                    type: inout
-                },
-            }
-        }
-    }
-}
diff --git a/linux_femu/rtl/axi_address_hijacker.v b/linux_femu/rtl/axi_address_hijacker.v
deleted file mode 100644
index e99c60e..0000000
--- a/linux_femu/rtl/axi_address_hijacker.v
+++ /dev/null
@@ -1,331 +0,0 @@
-// Copyright 2022 EPFL
-// Solderpad Hardware License, Version 2.1, see LICENSE.md for details.
-// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1
-
-module axi_address_hijacker #
-(
-  parameter integer AXI_ADDR_WIDTH = 32,
-  parameter integer C_S_AXI_DATA_WIDTH = 32,
-  parameter integer C_S_AXI_ADDR_WIDTH = 4
-)(
-  input wire [AXI_ADDR_WIDTH-1:0] axi_master_awaddr_in,
-  input wire [AXI_ADDR_WIDTH-1:0] axi_master_araddr_in,
-
-  output wire [AXI_ADDR_WIDTH-1:0] axi_master_araddr_out,
-  output wire [AXI_ADDR_WIDTH-1:0] axi_master_awaddr_out,
-
-  /////////////////////////////////////////
-  // AXI-Lite slave interface
-  /////////////////////////////////////////
-
-  // clock and reset
-  input wire S_AXI_ACLK,
-  input wire S_AXI_ARESETN,
-
-  // write address
-  input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR,
-  input wire [2 : 0] S_AXI_AWPROT,
-  input wire S_AXI_AWVALID,
-  output wire S_AXI_AWREADY,
-
-  // write data
-  input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA,
-  input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB,
-  input wire S_AXI_WVALID,
-  output wire S_AXI_WREADY,
-
-  // write response
-  output wire [1 : 0] S_AXI_BRESP,
-  output wire S_AXI_BVALID,
-  input wire S_AXI_BREADY,
-
-  // read address
-  input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR,
-  input wire [2 : 0] S_AXI_ARPROT,
-  input wire S_AXI_ARVALID,
-  output wire S_AXI_ARREADY,
-
-  // read data
-  output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA,
-  output wire [1 : 0] S_AXI_RRESP,
-  output wire S_AXI_RVALID,
-  input wire S_AXI_RREADY
-);
-
-  reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_awaddr;
-  reg axi_awready;
-  reg axi_wready;
-  reg [1 : 0] axi_bresp;
-  reg axi_bvalid;
-  reg [C_S_AXI_ADDR_WIDTH-1 : 0] axi_araddr;
-  reg axi_arready;
-  reg [C_S_AXI_DATA_WIDTH-1 : 0] axi_rdata;
-  reg [1 : 0] axi_rresp;
-  reg axi_rvalid;
-
-  localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1;
-  localparam integer OPT_MEM_ADDR_BITS = 1;
-
-  reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg0;
-  reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg1;
-  reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg2;
-  reg [C_S_AXI_DATA_WIDTH-1:0] slv_reg3;
-  wire slv_reg_rden;
-  wire slv_reg_wren;
-  reg [C_S_AXI_DATA_WIDTH-1:0] reg_data_out;
-  integer byte_index;
-  reg aw_en;
-
-  assign S_AXI_AWREADY = axi_awready;
-  assign S_AXI_WREADY = axi_wready;
-  assign S_AXI_BRESP  = axi_bresp;
-  assign S_AXI_BVALID = axi_bvalid;
-  assign S_AXI_ARREADY = axi_arready;
-  assign S_AXI_RDATA  = axi_rdata;
-  assign S_AXI_RRESP  = axi_rresp;
-  assign S_AXI_RVALID = axi_rvalid;
-
-  // Implement axi_awready generation
-  // axi_awready is asserted for one S_AXI_ACLK clock cycle when both
-  // S_AXI_AWVALID and S_AXI_WVALID are asserted. axi_awready is
-  // de-asserted when reset is low.
-  always @( posedge S_AXI_ACLK )
-  begin
-    if ( S_AXI_ARESETN == 1'b0 )
-      begin
-        axi_awready <= 1'b0;
-        aw_en <= 1'b1;
-      end
-    else
-      begin
-        if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID && aw_en)
-          begin
-            axi_awready <= 1'b1;
-            aw_en <= 1'b0;
-          end
-          else if (S_AXI_BREADY && axi_bvalid)
-              begin
-                aw_en <= 1'b1;
-                axi_awready <= 1'b0;
-              end
-        else
-          begin
-            axi_awready <= 1'b0;
-          end
-      end
-  end
-
-  // Implement axi_awaddr latching
-  // This process is used to latch the address when both
-  // S_AXI_AWVALID and S_AXI_WVALID are valid.
-  always @( posedge S_AXI_ACLK )
-  begin
-    if ( S_AXI_ARESETN == 1'b0 )
-      begin
-        axi_awaddr <= 0;
-      end
-    else
-      begin
-        if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID && aw_en)
-          begin
-            axi_awaddr <= S_AXI_AWADDR;
-          end
-      end
-  end
-
-  // Implement axi_wready generation
-  // axi_wready is asserted for one S_AXI_ACLK clock cycle when both
-  // S_AXI_AWVALID and S_AXI_WVALID are asserted. axi_wready is
-  // de-asserted when reset is low.
-  always @( posedge S_AXI_ACLK )
-  begin
-    if ( S_AXI_ARESETN == 1'b0 )
-      begin
-        axi_wready <= 1'b0;
-      end
-    else
-      begin
-        if (~axi_wready && S_AXI_WVALID && S_AXI_AWVALID && aw_en )
-          begin
-            axi_wready <= 1'b1;
-          end
-        else
-          begin
-            axi_wready <= 1'b0;
-          end
-      end
-  end
-
-  // Implement memory mapped register select and write logic generation
-  // The write data is accepted and written to memory mapped registers when
-  // axi_awready, S_AXI_WVALID, axi_wready and S_AXI_WVALID are asserted. Write strobes are used to
-  // select byte enables of slave registers while writing.
-  // These registers are cleared when reset (active low) is applied.
-  // Slave register write enable is asserted when valid address and data are available
-  // and the slave is ready to accept the write address and write data.
-  assign slv_reg_wren = axi_wready && S_AXI_WVALID && axi_awready && S_AXI_AWVALID;
-
-  always @( posedge S_AXI_ACLK )
-  begin
-    if ( S_AXI_ARESETN == 1'b0 )
-      begin
-        slv_reg0 <= 0;
-        slv_reg1 <= 0;
-        slv_reg2 <= 0;
-        slv_reg3 <= 0;
-      end
-    else begin
-      if (slv_reg_wren)
-        begin
-          case ( axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )
-            2'h0:
-              for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
-                if ( S_AXI_WSTRB[byte_index] == 1 ) begin
-                  slv_reg0[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
-                end
-            2'h1:
-              for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
-                if ( S_AXI_WSTRB[byte_index] == 1 ) begin
-                  slv_reg1[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
-                end
-            2'h2:
-              for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
-                if ( S_AXI_WSTRB[byte_index] == 1 ) begin
-                  slv_reg2[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
-                end
-            2'h3:
-              for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
-                if ( S_AXI_WSTRB[byte_index] == 1 ) begin
-                  slv_reg3[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
-                end
-            default : begin
-              slv_reg0 <= slv_reg0;
-              slv_reg1 <= slv_reg1;
-              slv_reg2 <= slv_reg2;
-              slv_reg3 <= slv_reg3;
-            end
-          endcase
-        end
-    end
-  end
-
-  // Implement write response logic generation
-  // The write response and response valid signals are asserted by the slave
-  // when axi_wready, S_AXI_WVALID, axi_wready and S_AXI_WVALID are asserted.
-  // This marks the acceptance of address and indicates the status of
-  // write transaction.
-  always @( posedge S_AXI_ACLK )
-  begin
-    if ( S_AXI_ARESETN == 1'b0 )
-      begin
-        axi_bvalid  <= 0;
-        axi_bresp   <= 2'b0;
-      end
-    else
-      begin
-        if (axi_awready && S_AXI_AWVALID && ~axi_bvalid && axi_wready && S_AXI_WVALID)
-          begin
-            axi_bvalid <= 1'b1;
-            axi_bresp  <= 2'b0;
-          end
-        else
-          begin
-            if (S_AXI_BREADY && axi_bvalid)
-              begin
-                axi_bvalid <= 1'b0;
-              end
-          end
-      end
-  end
-
-  // Implement axi_arready generation
-  // axi_arready is asserted for one S_AXI_ACLK clock cycle when
-  // S_AXI_ARVALID is asserted. axi_awready is
-  // de-asserted when reset (active low) is asserted.
-  // The read address is also latched when S_AXI_ARVALID is
-  // asserted. axi_araddr is reset to zero on reset assertion.
-  always @( posedge S_AXI_ACLK )
-  begin
-    if ( S_AXI_ARESETN == 1'b0 )
-      begin
-        axi_arready <= 1'b0;
-        axi_araddr  <= 32'b0;
-      end
-    else
-      begin
-        if (~axi_arready && S_AXI_ARVALID)
-          begin
-            axi_arready <= 1'b1;
-            axi_araddr  <= S_AXI_ARADDR;
-          end
-        else
-          begin
-            axi_arready <= 1'b0;
-          end
-      end
-  end
-
-  // Implement axi_arvalid generation
-  // axi_rvalid is asserted for one S_AXI_ACLK clock cycle when both
-  // S_AXI_ARVALID and axi_arready are asserted. The slave registers
-  // data are available on the axi_rdata bus at this instance. The
-  // assertion of axi_rvalid marks the validity of read data on the
-  // bus and axi_rresp indicates the status of read transaction.axi_rvalid
-  // is deasserted on reset (active low). axi_rresp and axi_rdata are
-  // cleared to zero on reset (active low).
-  always @( posedge S_AXI_ACLK )
-  begin
-    if ( S_AXI_ARESETN == 1'b0 )
-      begin
-        axi_rvalid <= 0;
-        axi_rresp  <= 0;
-      end
-    else
-      begin
-        if (axi_arready && S_AXI_ARVALID && ~axi_rvalid)
-          begin
-            axi_rvalid <= 1'b1;
-            axi_rresp  <= 2'b0;
-          end
-        else if (axi_rvalid && S_AXI_RREADY)
-          begin
-            axi_rvalid <= 1'b0;
-          end
-      end
-  end
-
-  // Implement memory mapped register select and read logic generation
-  // Slave register read enable is asserted when valid address is available
-  // and the slave is ready to accept the read address.
-  assign slv_reg_rden = axi_arready & S_AXI_ARVALID & ~axi_rvalid;
-  always @(*)
-  begin
-    case ( axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )
-      2'h0 : reg_data_out <= slv_reg0;
-      2'h1 : reg_data_out <= slv_reg1;
-      2'h2 : reg_data_out <= slv_reg2;
-      2'h3 : reg_data_out <= slv_reg3;
-      default : reg_data_out <= 0;
-    endcase
-  end
-
-  // Output register or memory read data
-  always @( posedge S_AXI_ACLK )
-  begin
-    if ( S_AXI_ARESETN == 1'b0 )
-      begin
-        axi_rdata <= 0;
-      end
-    else
-      begin
-        if (slv_reg_rden)
-          begin
-            axi_rdata <= reg_data_out;
-          end
-      end
-  end
-
-  assign axi_master_araddr_out = axi_master_araddr_in + slv_reg0;
-  assign axi_master_awaddr_out = axi_master_awaddr_in + slv_reg0;
-
-  endmodule
diff --git a/linux_femu/rtl/linux_femu.sv b/linux_femu/rtl/linux_femu.sv
deleted file mode 100644
index b605bd8..0000000
--- a/linux_femu/rtl/linux_femu.sv
+++ /dev/null
@@ -1,1272 +0,0 @@
-// Copyright 2022 EPFL
-// Solderpad Hardware License, Version 2.1, see LICENSE.md for details.
-// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1
-
-module linux_femu
-  import obi_pkg::*;
-  import reg_pkg::*;
-#(
-  parameter PULP_XPULP           = 0,
-  parameter FPU                  = 0,
-  parameter PULP_ZFINX           = 0,
-  parameter EXT_XBAR_NMASTER     = 0,
-  parameter CLK_LED_COUNT_LENGTH = 27
-) (
-  inout logic clk_in,
-  inout logic rst_i,
-
-  output logic rst_led,
-  output logic clk_led,
-  output logic clk_out,
-
-  inout logic boot_select_i,
-  inout logic execute_from_flash_i,
-
-  inout logic [29:0] gpio_io,
-
-  output logic exit_value_o,
-  inout  logic exit_valid_o,
-
-  inout logic spi_sd_0_io,
-  inout logic spi_sd_1_io,
-  inout logic spi_sd_2_io,
-  inout logic spi_sd_3_io,
-  inout logic spi_csb_io,
-  inout logic spi_sck_io,
-
-  inout logic spi2_sd_0_io,
-  inout logic spi2_sd_1_io,
-  inout logic spi2_sd_2_io,
-  inout logic spi2_sd_3_io,
-  inout logic [1:0] spi2_csb_io,
-  inout logic spi2_sck_io,
-
-  inout logic i2c_scl_io,
-  inout logic i2c_sda_io,
-
-  inout wire [14:0] DDR_addr,
-  inout wire [2:0] DDR_ba,
-  inout wire DDR_cas_n,
-  inout wire DDR_ck_n,
-  inout wire DDR_ck_p,
-  inout wire DDR_cke,
-  inout wire DDR_cs_n,
-  inout wire [3:0] DDR_dm,
-  inout wire [31:0] DDR_dq,
-  inout wire [3:0] DDR_dqs_n,
-  inout wire [3:0] DDR_dqs_p,
-  inout wire DDR_odt,
-  inout wire DDR_ras_n,
-  inout wire DDR_reset_n,
-  inout wire DDR_we_n,
-  inout wire FIXED_IO_ddr_vrn,
-  inout wire FIXED_IO_ddr_vrp,
-  inout wire [53:0] FIXED_IO_mio,
-  inout wire FIXED_IO_ps_clk,
-  inout wire FIXED_IO_ps_porb,
-  inout wire FIXED_IO_ps_srstb
-);
-
-  import core_v_mini_mcu_pkg::*;
-
-  parameter AXI_ADDR_WIDTH = 32;
-  parameter AXI_ADDR_WIDTH_SLAVE = 4;
-  parameter AXI_DATA_WIDTH = 32;
-
-  // PM signals
-  logic cpu_subsystem_powergate_switch;
-  logic cpu_subsystem_powergate_switch_ack;
-  logic cpu_subsystem_powergate_iso;
-  logic cpu_subsystem_rst_n;
-  logic peripheral_subsystem_powergate_switch;
-  logic peripheral_subsystem_powergate_switch_ack;
-  logic peripheral_subsystem_powergate_iso;
-  logic peripheral_subsystem_rst_n;
-  logic [core_v_mini_mcu_pkg::NUM_BANKS-1:0] memory_subsystem_banks_powergate_switch;
-  logic [core_v_mini_mcu_pkg::NUM_BANKS-1:0] memory_subsystem_banks_powergate_switch_ack;
-  logic [core_v_mini_mcu_pkg::NUM_BANKS-1:0] memory_subsystem_banks_powergate_iso;
-  logic [core_v_mini_mcu_pkg::NUM_BANKS-1:0] memory_subsystem_banks_set_retentive;
-
-  // PS SIDE PORTS
-  logic AXI_HP_ACLK;
-  logic AXI_HP_ARESETN;
-  logic [AXI_ADDR_WIDTH - 1:0] AXI_HP_araddr_sig;
-  logic [1:0] AXI_HP_arburst_sig;
-  logic [3:0] AXI_HP_arcache_sig;
-  logic [5:0] AXI_HP_arid_sig;
-  logic [3:0] AXI_HP_arlen_sig;
-  logic [1:0] AXI_HP_arlock_sig;
-  logic [2:0] AXI_HP_arprot_sig;
-  logic [3:0] AXI_HP_arqos_sig;
-  logic AXI_HP_arready_sig;
-  logic [2:0] AXI_HP_arsize_sig;
-  logic AXI_HP_arvalid_sig;
-  logic [AXI_ADDR_WIDTH - 1:0] AXI_HP_awaddr_sig;
-  logic [1:0] AXI_HP_awburst_sig;
-  logic [3:0] AXI_HP_awcache_sig;
-  logic [5:0] AXI_HP_awid_sig;
-  logic [3:0] AXI_HP_awlen_sig;
-  logic [1:0] AXI_HP_awlock_sig;
-  logic [2:0] AXI_HP_awprot_sig;
-  logic [3:0] AXI_HP_awqos_sig;
-  logic AXI_HP_awready_sig;
-  logic [2:0] AXI_HP_awsize_sig;
-  logic AXI_HP_awvalid_sig;
-  logic [5:0] AXI_HP_bid_sig;
-  logic AXI_HP_bready_sig;
-  logic [1:0] AXI_HP_bresp_sig;
-  logic AXI_HP_bvalid_sig;
-  logic [AXI_DATA_WIDTH - 1:0] AXI_HP_rdata_sig;
-  logic [5:0] AXI_HP_rid_sig;
-  logic AXI_HP_rlast_sig;
-  logic AXI_HP_rready_sig;
-  logic [1:0] AXI_HP_rresp_sig;
-  logic AXI_HP_rvalid_sig;
-  logic [AXI_DATA_WIDTH - 1:0] AXI_HP_wdata_sig;
-  logic [5:0] AXI_HP_wid_sig;
-  logic AXI_HP_wlast_sig;
-  logic AXI_HP_wready_sig;
-  logic [3:0] AXI_HP_wstrb_sig;
-  logic AXI_HP_wvalid_sig;
-
-  logic spi_test_clk_sig;
-  logic spi_test_cs_sig;
-  logic [3:0] spi_test_data_sig;
-
-  // ADDRESS HIJACKER PORTS
-  logic [AXI_ADDR_WIDTH-1:0] axi_master_awaddr_in_sig;
-  logic [AXI_ADDR_WIDTH-1:0] axi_master_araddr_in_sig;
-
-  logic [AXI_ADDR_WIDTH_SLAVE - 1 : 0] s00_axi_awaddr_sig;
-  logic s00_axi_awvalid_sig;
-  logic s00_axi_awready_sig;
-  logic [AXI_DATA_WIDTH - 1 : 0] s00_axi_wdata_sig;
-  logic s00_axi_wvalid_sig;
-  logic s00_axi_wready_sig;
-  logic s00_axi_bvalid_sig;
-  logic s00_axi_bready_sig;
-  logic [(AXI_DATA_WIDTH / 8)-1 : 0] s00_axi_wstrb_sig;
-  logic [2 : 0] s00_axi_arprot_sig;
-  logic [2 : 0] s00_axi_awprot_sig;
-  logic [AXI_ADDR_WIDTH_SLAVE - 1 : 0] s00_axi_araddr_sig;
-  logic s00_axi_arvalid_sig;
-  logic s00_axi_arready_sig;
-  logic [AXI_DATA_WIDTH - 1 : 0] s00_axi_rdata_sig;
-  logic s00_axi_rvalid_sig;
-  logic s00_axi_rready_sig;
-  logic [1:0] s00_axi_rresp_sig;
-  logic [1:0] s00_axi_bresp_sig;
-
-  // PAD controller
-  reg_req_t pad_req;
-  reg_rsp_t pad_resp;
-  logic [core_v_mini_mcu_pkg::NUM_PAD-1:0][7:0] pad_attributes;
-  logic [core_v_mini_mcu_pkg::NUM_PAD-1:0][3:0] pad_muxes;
-
-  logic rst_ngen;
-
-  // input, output pins from core_v_mini_mcu
-  logic clk_in_x,clk_out_x,clk_oe_x;
-
-  logic rst_nin_x,rst_nout_x,rst_noe_x;
-
-  logic boot_select_in_x,boot_select_out_x,boot_select_oe_x;
-
-  logic execute_from_flash_in_x,execute_from_flash_out_x,execute_from_flash_oe_x;
-
-  logic jtag_tck_in_x,jtag_tck_out_x,jtag_tck_oe_x;
-
-  logic jtag_tms_in_x,jtag_tms_out_x,jtag_tms_oe_x;
-
-  logic jtag_trst_nin_x,jtag_trst_nout_x,jtag_trst_noe_x;
-
-  logic jtag_tdi_in_x,jtag_tdi_out_x,jtag_tdi_oe_x;
-
-  logic jtag_tdo_in_x,jtag_tdo_out_x,jtag_tdo_oe_x;
-
-  logic uart_rx_in_x,uart_rx_out_x,uart_rx_oe_x;
-
-  logic uart_tx_in_x,uart_tx_out_x,uart_tx_oe_x;
-
-  logic exit_valid_in_x,exit_valid_out_x,exit_valid_oe_x;
-
-  logic gpio_0_in_x,gpio_0_out_x,gpio_0_oe_x;
-
-  logic gpio_1_in_x,gpio_1_out_x,gpio_1_oe_x;
-
-  logic gpio_2_in_x,gpio_2_out_x,gpio_2_oe_x;
-
-  logic gpio_3_in_x,gpio_3_out_x,gpio_3_oe_x;
-
-  logic gpio_4_in_x,gpio_4_out_x,gpio_4_oe_x;
-
-  logic gpio_5_in_x,gpio_5_out_x,gpio_5_oe_x;
-
-  logic gpio_6_in_x,gpio_6_out_x,gpio_6_oe_x;
-
-  logic gpio_7_in_x,gpio_7_out_x,gpio_7_oe_x;
-
-  logic gpio_8_in_x,gpio_8_out_x,gpio_8_oe_x;
-
-  logic gpio_9_in_x,gpio_9_out_x,gpio_9_oe_x;
-
-  logic gpio_10_in_x,gpio_10_out_x,gpio_10_oe_x;
-
-  logic gpio_11_in_x,gpio_11_out_x,gpio_11_oe_x;
-
-  logic gpio_12_in_x,gpio_12_out_x,gpio_12_oe_x;
-
-  logic gpio_13_in_x,gpio_13_out_x,gpio_13_oe_x;
-
-  logic gpio_14_in_x,gpio_14_out_x,gpio_14_oe_x;
-
-  logic gpio_15_in_x,gpio_15_out_x,gpio_15_oe_x;
-
-  logic gpio_16_in_x,gpio_16_out_x,gpio_16_oe_x;
-
-  logic gpio_17_in_x,gpio_17_out_x,gpio_17_oe_x;
-
-  logic gpio_18_in_x,gpio_18_out_x,gpio_18_oe_x;
-
-  logic gpio_19_in_x,gpio_19_out_x,gpio_19_oe_x;
-
-  logic gpio_20_in_x,gpio_20_out_x,gpio_20_oe_x;
-
-  logic gpio_21_in_x,gpio_21_out_x,gpio_21_oe_x;
-
-  logic gpio_22_in_x,gpio_22_out_x,gpio_22_oe_x;
-
-  logic spi_flash_sck_in_x,spi_flash_sck_out_x,spi_flash_sck_oe_x;
-
-  logic spi_flash_cs_0_in_x,spi_flash_cs_0_out_x,spi_flash_cs_0_oe_x;
-
-  logic spi_flash_cs_1_in_x,spi_flash_cs_1_out_x,spi_flash_cs_1_oe_x;
-
-  logic spi_flash_sd_0_in_x,spi_flash_sd_0_out_x,spi_flash_sd_0_oe_x;
-
-  logic spi_flash_sd_1_in_x,spi_flash_sd_1_out_x,spi_flash_sd_1_oe_x;
-
-  logic spi_flash_sd_2_in_x,spi_flash_sd_2_out_x,spi_flash_sd_2_oe_x;
-
-  logic spi_flash_sd_3_in_x,spi_flash_sd_3_out_x,spi_flash_sd_3_oe_x;
-
-  logic spi_sck_in_x,spi_sck_out_x,spi_sck_oe_x;
-
-  logic spi_cs_0_in_x,spi_cs_0_out_x,spi_cs_0_oe_x;
-
-  logic spi_cs_1_in_x,spi_cs_1_out_x,spi_cs_1_oe_x;
-
-  logic spi_sd_0_in_x,spi_sd_0_out_x,spi_sd_0_oe_x;
-
-  logic spi_sd_1_in_x,spi_sd_1_out_x,spi_sd_1_oe_x;
-
-  logic spi_sd_2_in_x,spi_sd_2_out_x,spi_sd_2_oe_x;
-
-  logic spi_sd_3_in_x,spi_sd_3_out_x,spi_sd_3_oe_x;
-
-  logic spi2_cs_0_in_x,spi2_cs_0_out_x,spi2_cs_0_oe_x;
-  logic gpio_23_in_x,gpio_23_out_x,gpio_23_oe_x;
-  logic spi2_cs_0_in_x_muxed,spi2_cs_0_out_x_muxed,spi2_cs_0_oe_x_muxed;
-
-  logic spi2_cs_1_in_x,spi2_cs_1_out_x,spi2_cs_1_oe_x;
-  logic gpio_24_in_x,gpio_24_out_x,gpio_24_oe_x;
-  logic spi2_cs_1_in_x_muxed,spi2_cs_1_out_x_muxed,spi2_cs_1_oe_x_muxed;
-
-  logic spi2_sck_in_x,spi2_sck_out_x,spi2_sck_oe_x;
-  logic gpio_25_in_x,gpio_25_out_x,gpio_25_oe_x;
-  logic spi2_sck_in_x_muxed,spi2_sck_out_x_muxed,spi2_sck_oe_x_muxed;
-
-  logic spi2_sd_0_in_x,spi2_sd_0_out_x,spi2_sd_0_oe_x;
-  logic gpio_26_in_x,gpio_26_out_x,gpio_26_oe_x;
-  logic spi2_sd_0_in_x_muxed,spi2_sd_0_out_x_muxed,spi2_sd_0_oe_x_muxed;
-
-  logic spi2_sd_1_in_x,spi2_sd_1_out_x,spi2_sd_1_oe_x;
-  logic gpio_27_in_x,gpio_27_out_x,gpio_27_oe_x;
-  logic spi2_sd_1_in_x_muxed,spi2_sd_1_out_x_muxed,spi2_sd_1_oe_x_muxed;
-
-  logic spi2_sd_2_in_x,spi2_sd_2_out_x,spi2_sd_2_oe_x;
-  logic gpio_28_in_x,gpio_28_out_x,gpio_28_oe_x;
-  logic spi2_sd_2_in_x_muxed,spi2_sd_2_out_x_muxed,spi2_sd_2_oe_x_muxed;
-
-  logic spi2_sd_3_in_x,spi2_sd_3_out_x,spi2_sd_3_oe_x;
-  logic gpio_29_in_x,gpio_29_out_x,gpio_29_oe_x;
-  logic spi2_sd_3_in_x_muxed,spi2_sd_3_out_x_muxed,spi2_sd_3_oe_x_muxed;
-
-  logic i2c_scl_in_x,i2c_scl_out_x,i2c_scl_oe_x;
-  logic gpio_31_in_x,gpio_31_out_x,gpio_31_oe_x;
-  logic i2c_scl_in_x_muxed,i2c_scl_out_x_muxed,i2c_scl_oe_x_muxed;
-
-  logic i2c_sda_in_x,i2c_sda_out_x,i2c_sda_oe_x;
-  logic gpio_30_in_x,gpio_30_out_x,gpio_30_oe_x;
-  logic i2c_sda_in_x_muxed,i2c_sda_out_x_muxed,i2c_sda_oe_x_muxed;
-
-
-  wire                               clk_gen;
-  logic [                      31:0] exit_value;
-  wire                               rst_n;
-  logic [CLK_LED_COUNT_LENGTH - 1:0] clk_count;
-
-  // low active reset
-  assign rst_n   = !rst_i;
-
-  // reset LED for debugging
-  assign rst_led = rst_n;
-
-  // counter to blink an LED
-  assign clk_led = clk_count[CLK_LED_COUNT_LENGTH-1];
-
-  always_ff @(posedge clk_gen or negedge rst_n) begin : clk_count_process
-    if (!rst_n) begin
-      clk_count <= '0;
-    end else begin
-      clk_count <= clk_count + 1;
-    end
-  end
-
-  // clock output for debugging
-  assign clk_out = clk_gen;
-
-  xilinx_clk_wizard_wrapper xilinx_clk_wizard_wrapper_i (
-    .clk_125MHz(clk_in),
-    .clk_out1_0(clk_gen)
-  );
-
-  logic clk_i;
-  assign clk_i = clk_gen;
-
-  core_v_mini_mcu #(
-    .PULP_XPULP(PULP_XPULP),
-    .FPU(FPU),
-    .PULP_ZFINX(PULP_ZFINX),
-    .EXT_XBAR_NMASTER(EXT_XBAR_NMASTER)
-  ) core_v_mini_mcu_i (
-
-    .rst_ni(rst_ngen),
-    .clk_i(clk_in_x),
-
-
-    .boot_select_i(boot_select_in_x),
-
-    .execute_from_flash_i(execute_from_flash_in_x),
-
-    .jtag_tck_i(jtag_tck_in_x),
-
-    .jtag_tms_i(jtag_tms_in_x),
-
-    .jtag_trst_ni(jtag_trst_nin_x),
-
-    .jtag_tdi_i(jtag_tdi_in_x),
-
-    .jtag_tdo_o(jtag_tdo_out_x),
-
-    .uart_rx_i(uart_rx_in_x),
-
-    .uart_tx_o(uart_tx_out_x),
-
-    .exit_valid_o(exit_valid_out_x),
-
-    .gpio_0_i(gpio_0_in_x),
-    .gpio_0_o(gpio_0_out_x),
-    .gpio_0_oe_o(gpio_0_oe_x),
-
-    .gpio_1_i(gpio_1_in_x),
-    .gpio_1_o(gpio_1_out_x),
-    .gpio_1_oe_o(gpio_1_oe_x),
-
-    .gpio_2_i(gpio_2_in_x),
-    .gpio_2_o(gpio_2_out_x),
-    .gpio_2_oe_o(gpio_2_oe_x),
-
-    .gpio_3_i(gpio_3_in_x),
-    .gpio_3_o(gpio_3_out_x),
-    .gpio_3_oe_o(gpio_3_oe_x),
-
-    .gpio_4_i(gpio_4_in_x),
-    .gpio_4_o(gpio_4_out_x),
-    .gpio_4_oe_o(gpio_4_oe_x),
-
-    .gpio_5_i(gpio_5_in_x),
-    .gpio_5_o(gpio_5_out_x),
-    .gpio_5_oe_o(gpio_5_oe_x),
-
-    .gpio_6_i(gpio_6_in_x),
-    .gpio_6_o(gpio_6_out_x),
-    .gpio_6_oe_o(gpio_6_oe_x),
-
-    .gpio_7_i(gpio_7_in_x),
-    .gpio_7_o(gpio_7_out_x),
-    .gpio_7_oe_o(gpio_7_oe_x),
-
-    .gpio_8_i(gpio_8_in_x),
-    .gpio_8_o(gpio_8_out_x),
-    .gpio_8_oe_o(gpio_8_oe_x),
-
-    .gpio_9_i(gpio_9_in_x),
-    .gpio_9_o(gpio_9_out_x),
-    .gpio_9_oe_o(gpio_9_oe_x),
-
-    .gpio_10_i(gpio_10_in_x),
-    .gpio_10_o(gpio_10_out_x),
-    .gpio_10_oe_o(gpio_10_oe_x),
-
-    .gpio_11_i(gpio_11_in_x),
-    .gpio_11_o(gpio_11_out_x),
-    .gpio_11_oe_o(gpio_11_oe_x),
-
-    .gpio_12_i(gpio_12_in_x),
-    .gpio_12_o(gpio_12_out_x),
-    .gpio_12_oe_o(gpio_12_oe_x),
-
-    .gpio_13_i(gpio_13_in_x),
-    .gpio_13_o(gpio_13_out_x),
-    .gpio_13_oe_o(gpio_13_oe_x),
-
-    .gpio_14_i(gpio_14_in_x),
-    .gpio_14_o(gpio_14_out_x),
-    .gpio_14_oe_o(gpio_14_oe_x),
-
-    .gpio_15_i(gpio_15_in_x),
-    .gpio_15_o(gpio_15_out_x),
-    .gpio_15_oe_o(gpio_15_oe_x),
-
-    .gpio_16_i(gpio_16_in_x),
-    .gpio_16_o(gpio_16_out_x),
-    .gpio_16_oe_o(gpio_16_oe_x),
-
-    .gpio_17_i(gpio_17_in_x),
-    .gpio_17_o(gpio_17_out_x),
-    .gpio_17_oe_o(gpio_17_oe_x),
-
-    .gpio_18_i(gpio_18_in_x),
-    .gpio_18_o(gpio_18_out_x),
-    .gpio_18_oe_o(gpio_18_oe_x),
-
-    .gpio_19_i(gpio_19_in_x),
-    .gpio_19_o(gpio_19_out_x),
-    .gpio_19_oe_o(gpio_19_oe_x),
-
-    .gpio_20_i(gpio_20_in_x),
-    .gpio_20_o(gpio_20_out_x),
-    .gpio_20_oe_o(gpio_20_oe_x),
-
-    .gpio_21_i(gpio_21_in_x),
-    .gpio_21_o(gpio_21_out_x),
-    .gpio_21_oe_o(gpio_21_oe_x),
-
-    .gpio_22_i(gpio_22_in_x),
-    .gpio_22_o(gpio_22_out_x),
-    .gpio_22_oe_o(gpio_22_oe_x),
-
-    .spi_flash_sck_i(spi_flash_sck_in_x),
-    .spi_flash_sck_o(spi_flash_sck_out_x),
-    .spi_flash_sck_oe_o(spi_flash_sck_oe_x),
-
-    .spi_flash_cs_0_i(spi_flash_cs_0_in_x),
-    .spi_flash_cs_0_o(spi_flash_cs_0_out_x),
-    .spi_flash_cs_0_oe_o(spi_flash_cs_0_oe_x),
-
-    .spi_flash_cs_1_i(spi_flash_cs_1_in_x),
-    .spi_flash_cs_1_o(spi_flash_cs_1_out_x),
-    .spi_flash_cs_1_oe_o(spi_flash_cs_1_oe_x),
-
-    .spi_flash_sd_0_i(spi_flash_sd_0_in_x),
-    .spi_flash_sd_0_o(spi_flash_sd_0_out_x),
-    .spi_flash_sd_0_oe_o(spi_flash_sd_0_oe_x),
-
-    .spi_flash_sd_1_i(spi_flash_sd_1_in_x),
-    .spi_flash_sd_1_o(spi_flash_sd_1_out_x),
-    .spi_flash_sd_1_oe_o(spi_flash_sd_1_oe_x),
-
-    .spi_flash_sd_2_i(spi_flash_sd_2_in_x),
-    .spi_flash_sd_2_o(spi_flash_sd_2_out_x),
-    .spi_flash_sd_2_oe_o(spi_flash_sd_2_oe_x),
-
-    .spi_flash_sd_3_i(spi_flash_sd_3_in_x),
-    .spi_flash_sd_3_o(spi_flash_sd_3_out_x),
-    .spi_flash_sd_3_oe_o(spi_flash_sd_3_oe_x),
-
-    .spi_sck_i(spi_sck_in_x),
-    .spi_sck_o(spi_sck_out_x),
-    .spi_sck_oe_o(spi_sck_oe_x),
-
-    .spi_cs_0_i(spi_cs_0_in_x),
-    .spi_cs_0_o(spi_cs_0_out_x),
-    .spi_cs_0_oe_o(spi_cs_0_oe_x),
-
-    .spi_cs_1_i(spi_cs_1_in_x),
-    .spi_cs_1_o(spi_cs_1_out_x),
-    .spi_cs_1_oe_o(spi_cs_1_oe_x),
-
-    .spi_sd_0_i(spi_sd_0_in_x),
-    .spi_sd_0_o(spi_sd_0_out_x),
-    .spi_sd_0_oe_o(spi_sd_0_oe_x),
-
-    .spi_sd_1_i(spi_sd_1_in_x),
-    .spi_sd_1_o(spi_sd_1_out_x),
-    .spi_sd_1_oe_o(spi_sd_1_oe_x),
-
-    .spi_sd_2_i(spi_sd_2_in_x),
-    .spi_sd_2_o(spi_sd_2_out_x),
-    .spi_sd_2_oe_o(spi_sd_2_oe_x),
-
-    .spi_sd_3_i(spi_sd_3_in_x),
-    .spi_sd_3_o(spi_sd_3_out_x),
-    .spi_sd_3_oe_o(spi_sd_3_oe_x),
-
-    .spi2_cs_0_i(spi2_cs_0_in_x),
-    .spi2_cs_0_o(spi2_cs_0_out_x),
-    .spi2_cs_0_oe_o(spi2_cs_0_oe_x),
-    .gpio_23_i(gpio_23_in_x),
-    .gpio_23_o(gpio_23_out_x),
-    .gpio_23_oe_o(gpio_23_oe_x),
-
-    .spi2_cs_1_i(spi2_cs_1_in_x),
-    .spi2_cs_1_o(spi2_cs_1_out_x),
-    .spi2_cs_1_oe_o(spi2_cs_1_oe_x),
-    .gpio_24_i(gpio_24_in_x),
-    .gpio_24_o(gpio_24_out_x),
-    .gpio_24_oe_o(gpio_24_oe_x),
-
-    .spi2_sck_i(spi2_sck_in_x),
-    .spi2_sck_o(spi2_sck_out_x),
-    .spi2_sck_oe_o(spi2_sck_oe_x),
-    .gpio_25_i(gpio_25_in_x),
-    .gpio_25_o(gpio_25_out_x),
-    .gpio_25_oe_o(gpio_25_oe_x),
-
-    .spi2_sd_0_i(spi2_sd_0_in_x),
-    .spi2_sd_0_o(spi2_sd_0_out_x),
-    .spi2_sd_0_oe_o(spi2_sd_0_oe_x),
-    .gpio_26_i(gpio_26_in_x),
-    .gpio_26_o(gpio_26_out_x),
-    .gpio_26_oe_o(gpio_26_oe_x),
-
-    .spi2_sd_1_i(spi2_sd_1_in_x),
-    .spi2_sd_1_o(spi2_sd_1_out_x),
-    .spi2_sd_1_oe_o(spi2_sd_1_oe_x),
-    .gpio_27_i(gpio_27_in_x),
-    .gpio_27_o(gpio_27_out_x),
-    .gpio_27_oe_o(gpio_27_oe_x),
-
-    .spi2_sd_2_i(spi2_sd_2_in_x),
-    .spi2_sd_2_o(spi2_sd_2_out_x),
-    .spi2_sd_2_oe_o(spi2_sd_2_oe_x),
-    .gpio_28_i(gpio_28_in_x),
-    .gpio_28_o(gpio_28_out_x),
-    .gpio_28_oe_o(gpio_28_oe_x),
-
-    .spi2_sd_3_i(spi2_sd_3_in_x),
-    .spi2_sd_3_o(spi2_sd_3_out_x),
-    .spi2_sd_3_oe_o(spi2_sd_3_oe_x),
-    .gpio_29_i(gpio_29_in_x),
-    .gpio_29_o(gpio_29_out_x),
-    .gpio_29_oe_o(gpio_29_oe_x),
-
-    .i2c_scl_i(i2c_scl_in_x),
-    .i2c_scl_o(i2c_scl_out_x),
-    .i2c_scl_oe_o(i2c_scl_oe_x),
-    .gpio_31_i(gpio_31_in_x),
-    .gpio_31_o(gpio_31_out_x),
-    .gpio_31_oe_o(gpio_31_oe_x),
-
-    .i2c_sda_i(i2c_sda_in_x),
-    .i2c_sda_o(i2c_sda_out_x),
-    .i2c_sda_oe_o(i2c_sda_oe_x),
-    .gpio_30_i(gpio_30_in_x),
-    .gpio_30_o(gpio_30_out_x),
-    .gpio_30_oe_o(gpio_30_oe_x),
-
-    .intr_vector_ext_i('0),
-    .ext_xbar_master_req_i('0),
-    .ext_xbar_master_resp_o(),
-    .ext_xbar_slave_req_o(),
-    .ext_xbar_slave_resp_i('0),
-    .ext_peripheral_slave_req_o(),
-    .ext_peripheral_slave_resp_i('0),
-    .external_subsystem_powergate_switch_o(),
-    .external_subsystem_powergate_switch_ack_i(),
-    .external_subsystem_powergate_iso_o(),
-    .external_subsystem_rst_no(),
-    .external_ram_banks_set_retentive_o(),
-    .exit_value_o(exit_value),
-    .pad_req_o(pad_req),
-    .pad_resp_i(pad_resp),
-    .cpu_subsystem_powergate_switch_o(cpu_subsystem_powergate_switch),
-    .cpu_subsystem_powergate_switch_ack_i(cpu_subsystem_powergate_switch_ack),
-    .peripheral_subsystem_powergate_switch_o(peripheral_subsystem_powergate_switch),
-    .peripheral_subsystem_powergate_switch_ack_i(peripheral_subsystem_powergate_switch_ack),
-    .memory_subsystem_banks_powergate_switch_o(memory_subsystem_banks_powergate_switch),
-    .memory_subsystem_banks_powergate_switch_ack_i(memory_subsystem_banks_powergate_switch_ack)
-  );
-
-  logic gpio_0_io;
-  logic gpio_1_io;
-  logic gpio_2_io;
-  logic gpio_3_io;
-  logic gpio_4_io;
-  logic gpio_5_io;
-  logic gpio_6_io;
-  logic gpio_7_io;
-  logic gpio_8_io;
-  logic gpio_9_io;
-  logic gpio_10_io;
-  logic gpio_11_io;
-  logic gpio_12_io;
-  logic gpio_13_io;
-  logic gpio_14_io;
-  logic gpio_15_io;
-  logic gpio_16_io;
-  logic gpio_17_io;
-  logic gpio_18_io;
-  logic gpio_19_io;
-  logic gpio_20_io;
-  logic gpio_21_io;
-  logic gpio_22_io;
-
-  assign spi_flash_sck_o_sig = spi_flash_sck_out_x;
-  assign spi_flash_csb_o_sig = spi_flash_cs_0_out_x;
-  assign spi_sdi1_sig = spi_flash_sd_1_in_x;
-  assign spi_sdo0_sig = spi_flash_sd_0_out_x;
-  assign spi_sdo2_sig = spi_sd_2_out_x;
-  assign spi_sdo3_sig = spi_sd_3_out_x;
-
-  assign spi2_csb_io[0] = spi2_cs_0_io;
-  assign spi2_csb_io[1] = spi2_cs_1_io;
-
-  assign gpio_io[0] = gpio_0_io;
-  assign gpio_io[1] = gpio_1_io;
-  assign gpio_io[2] = gpio_2_io;
-  assign gpio_io[3] = gpio_3_io;
-  assign gpio_io[4] = gpio_4_io;
-  assign gpio_io[5] = gpio_5_io;
-  assign gpio_io[6] = gpio_6_io;
-  assign gpio_io[7] = gpio_7_io;
-  assign gpio_io[8] = gpio_8_io;
-  assign gpio_io[9] = gpio_9_io;
-  assign gpio_io[10] = gpio_10_io;
-  assign gpio_io[11] = gpio_11_io;
-  assign gpio_io[12] = gpio_12_io;
-  assign gpio_io[13] = gpio_13_io;
-  assign gpio_io[14] = gpio_14_io;
-  assign gpio_io[15] = gpio_15_io;
-  assign gpio_io[16] = gpio_16_io;
-  assign gpio_io[17] = gpio_17_io;
-  assign gpio_io[18] = gpio_18_io;
-  assign gpio_io[19] = gpio_19_io;
-  assign gpio_io[20] = gpio_20_io;
-  assign gpio_io[21] = gpio_21_io;
-  assign gpio_io[22] = gpio_22_io;
-
-  processing_system_wrapper processing_system_wrapper_i (
-    .DDR_addr(DDR_addr),
-    .DDR_ba(DDR_ba),
-    .DDR_cas_n(DDR_cas_n),
-    .DDR_ck_n(DDR_ck_n),
-    .DDR_ck_p(DDR_ck_p),
-    .DDR_cke(DDR_cke),
-    .DDR_cs_n(DDR_cs_n),
-    .DDR_dm(DDR_dm),
-    .DDR_dq(DDR_dq),
-    .DDR_dqs_n(DDR_dqs_n),
-    .DDR_dqs_p(DDR_dqs_p),
-    .DDR_odt(DDR_odt),
-    .DDR_ras_n(DDR_ras_n),
-    .DDR_reset_n(DDR_reset_n),
-    .DDR_we_n(DDR_we_n),
-    .FIXED_IO_ddr_vrn(FIXED_IO_ddr_vrn),
-    .FIXED_IO_ddr_vrp(FIXED_IO_ddr_vrp),
-    .FIXED_IO_mio(FIXED_IO_mio),
-    .FIXED_IO_ps_clk(FIXED_IO_ps_clk),
-    .FIXED_IO_ps_porb(FIXED_IO_ps_porb),
-    .FIXED_IO_ps_srstb(FIXED_IO_ps_srstb),
-    .UART_rxd(uart_tx_out_x),
-    .UART_txd(uart_rx_in_x),
-    .gpio_jtag_tck_i(jtag_tck_in_x),
-    .gpio_jtag_tms_i(jtag_tms_in_x),
-    .gpio_jtag_trst_ni(jtag_trst_nin_x),
-    .gpio_jtag_tdi_i(jtag_tdi_in_x),
-    .gpio_jtag_tdo_o(jtag_tdo_out_x),
-    .AXI_HP_ACLK(AXI_HP_ACLK),
-    .AXI_HP_ARESETN(AXI_HP_ARESETN),
-    .AXI_HP_araddr(AXI_HP_araddr_sig),
-    .AXI_HP_arburst(AXI_HP_arburst_sig),
-    .AXI_HP_arcache(AXI_HP_arcache_sig),
-    .AXI_HP_arlen(AXI_HP_arlen_sig),
-    .AXI_HP_arlock(AXI_HP_arlock_sig),
-    .AXI_HP_arprot(AXI_HP_arprot_sig),
-    .AXI_HP_arqos(AXI_HP_arqos_sig),
-    .AXI_HP_arready(AXI_HP_arready_sig),
-    .AXI_HP_arsize(AXI_HP_arsize_sig),
-    .AXI_HP_arvalid(AXI_HP_arvalid_sig),
-    .AXI_HP_awaddr(AXI_HP_awaddr_sig),
-    .AXI_HP_awburst(AXI_HP_awburst_sig),
-    .AXI_HP_awcache(AXI_HP_awcache_sig),
-    .AXI_HP_awlen(AXI_HP_awlen_sig),
-    .AXI_HP_awlock(AXI_HP_awlock_sig),
-    .AXI_HP_awprot(AXI_HP_awprot_sig),
-    .AXI_HP_awqos(AXI_HP_awqos_sig),
-    .AXI_HP_awready(AXI_HP_awready_sig),
-    .AXI_HP_awsize(AXI_HP_awsize_sig),
-    .AXI_HP_awvalid(AXI_HP_awvalid_sig),
-    .AXI_HP_bready(AXI_HP_bready_sig),
-    .AXI_HP_bresp(AXI_HP_bresp_sig),
-    .AXI_HP_bvalid(AXI_HP_bvalid_sig),
-    .AXI_HP_rdata(AXI_HP_rdata_sig),
-    .AXI_HP_rlast(AXI_HP_rlast_sig),
-    .AXI_HP_rready(AXI_HP_rready_sig),
-    .AXI_HP_rresp(AXI_HP_rresp_sig),
-    .AXI_HP_rvalid(AXI_HP_rvalid_sig),
-    .AXI_HP_wdata(AXI_HP_wdata_sig),
-    .AXI_HP_wlast(AXI_HP_wlast_sig),
-    .AXI_HP_wready(AXI_HP_wready_sig),
-    .AXI_HP_wstrb(AXI_HP_wstrb_sig),
-    .AXI_HP_wvalid(AXI_HP_wvalid_sig),
-    .M_AXI_araddr(s00_axi_araddr_sig),
-    .M_AXI_arready(s00_axi_arready_sig),
-    .M_AXI_arvalid(s00_axi_arvalid_sig),
-    .M_AXI_awaddr(s00_axi_awaddr_sig),
-    .M_AXI_awready(s00_axi_awready_sig),
-    .M_AXI_awvalid(s00_axi_awvalid_sig),
-    .M_AXI_bready(s00_axi_bready_sig),
-    .M_AXI_bresp(s00_axi_bresp_sig),
-    .M_AXI_bvalid(s00_axi_bvalid_sig),
-    .M_AXI_rdata(s00_axi_rdata_sig),
-    .M_AXI_rready(s00_axi_rready_sig),
-    .M_AXI_rresp(s00_axi_rresp_sig),
-    .M_AXI_rvalid(s00_axi_rvalid_sig),
-    .M_AXI_wdata(s00_axi_wdata_sig),
-    .M_AXI_wready(s00_axi_wready_sig),
-    .M_AXI_wvalid(s00_axi_wvalid_sig),
-    .M_AXI_awprot(s00_axi_awprot_sig),
-    .M_AXI_arprot(s00_axi_arprot_sig),
-    .M_AXI_wstrb(s00_axi_wstrb_sig)
-  );
-
-  axi_address_hijacker #(
-    .AXI_ADDR_WIDTH(AXI_ADDR_WIDTH),
-    .C_S_AXI_DATA_WIDTH(AXI_DATA_WIDTH)
-  ) add_hij (
-    .axi_master_awaddr_in(axi_master_awaddr_in_sig),
-    .axi_master_araddr_in(axi_master_araddr_in_sig),
-
-    // output write and read address by adding fixed offset
-    .axi_master_araddr_out(AXI_HP_araddr_sig),
-    .axi_master_awaddr_out(AXI_HP_awaddr_sig),
-
-    .S_AXI_ACLK(AXI_HP_ACLK),
-    .S_AXI_ARESETN(AXI_HP_ARESETN),
-
-    .S_AXI_AWADDR (s00_axi_awaddr_sig),
-    .S_AXI_AWPROT (s00_axi_awprot_sig),
-    .S_AXI_AWVALID(s00_axi_awvalid_sig),
-    .S_AXI_AWREADY(s00_axi_awready_sig),
-    .S_AXI_WDATA  (s00_axi_wdata_sig),
-    .S_AXI_WSTRB  (s00_axi_wstrb_sig),
-    .S_AXI_WVALID (s00_axi_wvalid_sig),
-    .S_AXI_WREADY (s00_axi_wready_sig),
-    .S_AXI_BRESP  (s00_axi_bresp_sig),
-    .S_AXI_BVALID (s00_axi_bvalid_sig),
-    .S_AXI_BREADY (s00_axi_bready_sig),
-    .S_AXI_ARADDR (s00_axi_araddr_sig),
-    .S_AXI_ARPROT (s00_axi_arprot_sig),
-    .S_AXI_ARVALID(s00_axi_arvalid_sig),
-    .S_AXI_ARREADY(s00_axi_arready_sig),
-    .S_AXI_RDATA  (s00_axi_rdata_sig),
-    .S_AXI_RRESP  (s00_axi_rresp_sig),
-    .S_AXI_RVALID (s00_axi_rvalid_sig),
-    .S_AXI_RREADY (s00_axi_rready_sig)
-  );
-
-  axi_spi_slave #(
-    .AXI_DATA_WIDTH(AXI_DATA_WIDTH)
-  ) fake_flash (
-    .axi_aclk(AXI_HP_ACLK),
-    .axi_aresetn(AXI_HP_ARESETN),
-
-    .test_mode('0),
-
-    .axi_master_aw_valid(AXI_HP_awvalid_sig),
-    .axi_master_aw_id(AXI_HP_awid_sig),
-    .axi_master_aw_prot(AXI_HP_awprot_sig),
-    .axi_master_aw_qos(AXI_HP_awqos_sig),
-    .axi_master_aw_cache(AXI_HP_awcache_sig),
-    .axi_master_aw_lock(AXI_HP_awlock_sig),
-    .axi_master_aw_burst(AXI_HP_awburst_sig),
-    .axi_master_aw_size(AXI_HP_awsize_sig),
-    .axi_master_aw_len(AXI_HP_awlen_sig),
-    .axi_master_aw_addr(axi_master_awaddr_in_sig),
-    .axi_master_aw_ready(AXI_HP_awready_sig),
-
-    .axi_master_w_valid(AXI_HP_wvalid_sig),
-    .axi_master_w_data (AXI_HP_wdata_sig),
-    .axi_master_w_strb (AXI_HP_wstrb_sig),
-    .axi_master_w_last (AXI_HP_wlast_sig),
-    .axi_master_w_ready(AXI_HP_wready_sig),
-
-    .axi_master_b_valid(AXI_HP_bvalid_sig),
-    .axi_master_b_id(AXI_HP_bid_sig),
-    .axi_master_b_resp(AXI_HP_bresp_sig),
-    .axi_master_b_ready(AXI_HP_bready_sig),
-
-    .axi_master_ar_valid(AXI_HP_arvalid_sig),
-    .axi_master_ar_id(AXI_HP_arid_sig),
-    .axi_master_ar_prot(AXI_HP_arprot_sig),
-    .axi_master_ar_qos(AXI_HP_arqos_sig),
-    .axi_master_ar_cache(AXI_HP_arcache_sig),
-    .axi_master_ar_lock(AXI_HP_arlock_sig),
-    .axi_master_ar_burst(AXI_HP_arburst_sig),
-    .axi_master_ar_size(AXI_HP_arsize_sig),
-    .axi_master_ar_len(AXI_HP_arlen_sig),
-    .axi_master_ar_addr(axi_master_araddr_in_sig),
-    .axi_master_ar_ready(AXI_HP_arready_sig),
-
-    .axi_master_r_valid(AXI_HP_rvalid_sig),
-    .axi_master_r_id(AXI_HP_rid_sig),
-    .axi_master_r_data(AXI_HP_rdata_sig),
-    .axi_master_r_resp(AXI_HP_rresp_sig),
-    .axi_master_r_last(AXI_HP_rlast_sig),
-    .axi_master_r_ready(AXI_HP_rready_sig),
-
-    .spi_sclk(spi_flash_sck_o_sig),
-    .spi_cs  (spi_flash_csb_o_sig),
-    .spi_sdo1(spi_sdi1_sig),
-    .spi_sdi0(spi_sdo0_sig),
-    .spi_sdi2(spi_sdo2_sig),
-    .spi_sdi3(spi_sdo3_sig)
-  );
-
-  // TESTING PURPOSES -> THEY WILL BE INPUT TO PS AND READ BY SYSTEM ILA
-  assign spi_test_clk_sig  = spi_flash_sck_o_sig;
-  assign spi_test_cs_sig   = spi_flash_csb_o_sig;
-  assign spi_test_data_sig = {spi_sdo0_sig, spi_sdi1_sig, spi_sdo2_sig, spi_sdo3_sig};
-
-  pad_ring pad_ring_i (
-    .clk_io(clk_i),
-    .clk_o(clk_in_x),
-    .rst_nio(rst_ni),
-    .rst_no(rst_nin_x),
-    .boot_select_io(boot_select_i),
-    .boot_select_o(boot_select_in_x),
-    .execute_from_flash_io(execute_from_flash_i),
-    .execute_from_flash_o(execute_from_flash_in_x),
-
-
-
-
-
-
-
-    .exit_valid_io(exit_valid_o),
-    .exit_valid_i(exit_valid_out_x),
-    .gpio_0_io(gpio_0_io),
-    .gpio_0_o(gpio_0_in_x),
-    .gpio_0_i(gpio_0_out_x),
-    .gpio_0_oe_i(gpio_0_oe_x),
-    .gpio_1_io(gpio_1_io),
-    .gpio_1_o(gpio_1_in_x),
-    .gpio_1_i(gpio_1_out_x),
-    .gpio_1_oe_i(gpio_1_oe_x),
-    .gpio_2_io(gpio_2_io),
-    .gpio_2_o(gpio_2_in_x),
-    .gpio_2_i(gpio_2_out_x),
-    .gpio_2_oe_i(gpio_2_oe_x),
-    .gpio_3_io(gpio_3_io),
-    .gpio_3_o(gpio_3_in_x),
-    .gpio_3_i(gpio_3_out_x),
-    .gpio_3_oe_i(gpio_3_oe_x),
-    .gpio_4_io(gpio_4_io),
-    .gpio_4_o(gpio_4_in_x),
-    .gpio_4_i(gpio_4_out_x),
-    .gpio_4_oe_i(gpio_4_oe_x),
-    .gpio_5_io(gpio_5_io),
-    .gpio_5_o(gpio_5_in_x),
-    .gpio_5_i(gpio_5_out_x),
-    .gpio_5_oe_i(gpio_5_oe_x),
-    .gpio_6_io(gpio_6_io),
-    .gpio_6_o(gpio_6_in_x),
-    .gpio_6_i(gpio_6_out_x),
-    .gpio_6_oe_i(gpio_6_oe_x),
-    .gpio_7_io(gpio_7_io),
-    .gpio_7_o(gpio_7_in_x),
-    .gpio_7_i(gpio_7_out_x),
-    .gpio_7_oe_i(gpio_7_oe_x),
-    .gpio_8_io(gpio_8_io),
-    .gpio_8_o(gpio_8_in_x),
-    .gpio_8_i(gpio_8_out_x),
-    .gpio_8_oe_i(gpio_8_oe_x),
-    .gpio_9_io(gpio_9_io),
-    .gpio_9_o(gpio_9_in_x),
-    .gpio_9_i(gpio_9_out_x),
-    .gpio_9_oe_i(gpio_9_oe_x),
-    .gpio_10_io(gpio_10_io),
-    .gpio_10_o(gpio_10_in_x),
-    .gpio_10_i(gpio_10_out_x),
-    .gpio_10_oe_i(gpio_10_oe_x),
-    .gpio_11_io(gpio_11_io),
-    .gpio_11_o(gpio_11_in_x),
-    .gpio_11_i(gpio_11_out_x),
-    .gpio_11_oe_i(gpio_11_oe_x),
-    .gpio_12_io(gpio_12_io),
-    .gpio_12_o(gpio_12_in_x),
-    .gpio_12_i(gpio_12_out_x),
-    .gpio_12_oe_i(gpio_12_oe_x),
-    .gpio_13_io(gpio_13_io),
-    .gpio_13_o(gpio_13_in_x),
-    .gpio_13_i(gpio_13_out_x),
-    .gpio_13_oe_i(gpio_13_oe_x),
-    .gpio_14_io(gpio_14_io),
-    .gpio_14_o(gpio_14_in_x),
-    .gpio_14_i(gpio_14_out_x),
-    .gpio_14_oe_i(gpio_14_oe_x),
-    .gpio_15_io(gpio_15_io),
-    .gpio_15_o(gpio_15_in_x),
-    .gpio_15_i(gpio_15_out_x),
-    .gpio_15_oe_i(gpio_15_oe_x),
-    .gpio_16_io(gpio_16_io),
-    .gpio_16_o(gpio_16_in_x),
-    .gpio_16_i(gpio_16_out_x),
-    .gpio_16_oe_i(gpio_16_oe_x),
-    .gpio_17_io(gpio_17_io),
-    .gpio_17_o(gpio_17_in_x),
-    .gpio_17_i(gpio_17_out_x),
-    .gpio_17_oe_i(gpio_17_oe_x),
-    .gpio_18_io(gpio_18_io),
-    .gpio_18_o(gpio_18_in_x),
-    .gpio_18_i(gpio_18_out_x),
-    .gpio_18_oe_i(gpio_18_oe_x),
-    .gpio_19_io(gpio_19_io),
-    .gpio_19_o(gpio_19_in_x),
-    .gpio_19_i(gpio_19_out_x),
-    .gpio_19_oe_i(gpio_19_oe_x),
-    .gpio_20_io(gpio_20_io),
-    .gpio_20_o(gpio_20_in_x),
-    .gpio_20_i(gpio_20_out_x),
-    .gpio_20_oe_i(gpio_20_oe_x),
-    .gpio_21_io(gpio_21_io),
-    .gpio_21_o(gpio_21_in_x),
-    .gpio_21_i(gpio_21_out_x),
-    .gpio_21_oe_i(gpio_21_oe_x),
-    .gpio_22_io(gpio_22_io),
-    .gpio_22_o(gpio_22_in_x),
-    .gpio_22_i(gpio_22_out_x),
-    .gpio_22_oe_i(gpio_22_oe_x),
-
-
-
-
-
-
-
-    .spi_sck_io(spi_sck_io),
-    .spi_sck_o(spi_sck_in_x),
-    .spi_sck_i(spi_sck_out_x),
-    .spi_sck_oe_i(spi_sck_oe_x),
-    .spi_cs_0_io(spi_cs_0_io),
-    .spi_cs_0_o(spi_cs_0_in_x),
-    .spi_cs_0_i(spi_cs_0_out_x),
-    .spi_cs_0_oe_i(spi_cs_0_oe_x),
-    .spi_cs_1_io(spi_cs_1_io),
-    .spi_cs_1_o(spi_cs_1_in_x),
-    .spi_cs_1_i(spi_cs_1_out_x),
-    .spi_cs_1_oe_i(spi_cs_1_oe_x),
-    .spi_sd_0_io(spi_sd_0_io),
-    .spi_sd_0_o(spi_sd_0_in_x),
-    .spi_sd_0_i(spi_sd_0_out_x),
-    .spi_sd_0_oe_i(spi_sd_0_oe_x),
-    .spi_sd_1_io(spi_sd_1_io),
-    .spi_sd_1_o(spi_sd_1_in_x),
-    .spi_sd_1_i(spi_sd_1_out_x),
-    .spi_sd_1_oe_i(spi_sd_1_oe_x),
-    .spi_sd_2_io(spi_sd_2_io),
-    .spi_sd_2_o(spi_sd_2_in_x),
-    .spi_sd_2_i(spi_sd_2_out_x),
-    .spi_sd_2_oe_i(spi_sd_2_oe_x),
-    .spi_sd_3_io(spi_sd_3_io),
-    .spi_sd_3_o(spi_sd_3_in_x),
-    .spi_sd_3_i(spi_sd_3_out_x),
-    .spi_sd_3_oe_i(spi_sd_3_oe_x),
-    .spi2_cs_0_io(spi2_cs_0_io),
-    .spi2_cs_0_o(spi2_cs_0_in_x_muxed),
-    .spi2_cs_0_i(spi2_cs_0_out_x_muxed),
-    .spi2_cs_0_oe_i(spi2_cs_0_oe_x_muxed),
-    .spi2_cs_1_io(spi2_cs_1_io),
-    .spi2_cs_1_o(spi2_cs_1_in_x_muxed),
-    .spi2_cs_1_i(spi2_cs_1_out_x_muxed),
-    .spi2_cs_1_oe_i(spi2_cs_1_oe_x_muxed),
-    .spi2_sck_io(spi2_sck_io),
-    .spi2_sck_o(spi2_sck_in_x_muxed),
-    .spi2_sck_i(spi2_sck_out_x_muxed),
-    .spi2_sck_oe_i(spi2_sck_oe_x_muxed),
-    .spi2_sd_0_io(spi2_sd_0_io),
-    .spi2_sd_0_o(spi2_sd_0_in_x_muxed),
-    .spi2_sd_0_i(spi2_sd_0_out_x_muxed),
-    .spi2_sd_0_oe_i(spi2_sd_0_oe_x_muxed),
-    .spi2_sd_1_io(spi2_sd_1_io),
-    .spi2_sd_1_o(spi2_sd_1_in_x_muxed),
-    .spi2_sd_1_i(spi2_sd_1_out_x_muxed),
-    .spi2_sd_1_oe_i(spi2_sd_1_oe_x_muxed),
-    .spi2_sd_2_io(spi2_sd_2_io),
-    .spi2_sd_2_o(spi2_sd_2_in_x_muxed),
-    .spi2_sd_2_i(spi2_sd_2_out_x_muxed),
-    .spi2_sd_2_oe_i(spi2_sd_2_oe_x_muxed),
-    .spi2_sd_3_io(spi2_sd_3_io),
-    .spi2_sd_3_o(spi2_sd_3_in_x_muxed),
-    .spi2_sd_3_i(spi2_sd_3_out_x_muxed),
-    .spi2_sd_3_oe_i(spi2_sd_3_oe_x_muxed),
-    .i2c_scl_io(i2c_scl_io),
-    .i2c_scl_o(i2c_scl_in_x_muxed),
-    .i2c_scl_i(i2c_scl_out_x_muxed),
-    .i2c_scl_oe_i(i2c_scl_oe_x_muxed),
-    .i2c_sda_io(i2c_sda_io),
-    .i2c_sda_o(i2c_sda_in_x_muxed),
-    .i2c_sda_i(i2c_sda_out_x_muxed),
-    .i2c_sda_oe_i(i2c_sda_oe_x_muxed),
-    .pad_attributes_i(pad_attributes)
-  );
-
-  assign clk_out_x = 1'b0;
-  assign clk_oe_x = 1'b0;
-  assign rst_nout_x = 1'b0;
-  assign rst_noe_x = 1'b0;
-  assign boot_select_out_x = 1'b0;
-  assign boot_select_oe_x = 1'b0;
-  assign execute_from_flash_out_x = 1'b0;
-  assign execute_from_flash_oe_x = 1'b0;
-  assign jtag_tck_out_x = 1'b0;
-  assign jtag_tck_oe_x = 1'b0;
-  assign jtag_tms_out_x = 1'b0;
-  assign jtag_tms_oe_x = 1'b0;
-  assign jtag_trst_nout_x = 1'b0;
-  assign jtag_trst_noe_x = 1'b0;
-  assign jtag_tdi_out_x = 1'b0;
-  assign jtag_tdi_oe_x = 1'b0;
-  assign jtag_tdo_oe_x = 1'b1;
-  assign uart_rx_out_x = 1'b0;
-  assign uart_rx_oe_x = 1'b0;
-  assign uart_tx_oe_x = 1'b1;
-  assign exit_valid_oe_x = 1'b1;
-
-
-  always_comb
-  begin
-   spi2_cs_0_in_x=1'b0;
-   gpio_23_in_x=1'b0;
-   unique case(pad_muxes[core_v_mini_mcu_pkg::PAD_SPI2_CS_0])
-    0: begin
-      spi2_cs_0_out_x_muxed = spi2_cs_0_out_x;
-      spi2_cs_0_oe_x_muxed = spi2_cs_0_oe_x;
-      spi2_cs_0_in_x = spi2_cs_0_in_x_muxed;
-    end
-    1: begin
-      spi2_cs_0_out_x_muxed = gpio_23_out_x;
-      spi2_cs_0_oe_x_muxed = gpio_23_oe_x;
-      gpio_23_in_x = spi2_cs_0_in_x_muxed;
-    end
-    default: begin
-      spi2_cs_0_out_x_muxed = spi2_cs_0_out_x;
-      spi2_cs_0_oe_x_muxed = spi2_cs_0_oe_x;
-      spi2_cs_0_in_x = spi2_cs_0_in_x_muxed;
-    end
-   endcase
-  end
-  always_comb
-  begin
-   spi2_cs_1_in_x=1'b0;
-   gpio_24_in_x=1'b0;
-   unique case(pad_muxes[core_v_mini_mcu_pkg::PAD_SPI2_CS_1])
-    0: begin
-      spi2_cs_1_out_x_muxed = spi2_cs_1_out_x;
-      spi2_cs_1_oe_x_muxed = spi2_cs_1_oe_x;
-      spi2_cs_1_in_x = spi2_cs_1_in_x_muxed;
-    end
-    1: begin
-      spi2_cs_1_out_x_muxed = gpio_24_out_x;
-      spi2_cs_1_oe_x_muxed = gpio_24_oe_x;
-      gpio_24_in_x = spi2_cs_1_in_x_muxed;
-    end
-    default: begin
-      spi2_cs_1_out_x_muxed = spi2_cs_1_out_x;
-      spi2_cs_1_oe_x_muxed = spi2_cs_1_oe_x;
-      spi2_cs_1_in_x = spi2_cs_1_in_x_muxed;
-    end
-   endcase
-  end
-  always_comb
-  begin
-   spi2_sck_in_x=1'b0;
-   gpio_25_in_x=1'b0;
-   unique case(pad_muxes[core_v_mini_mcu_pkg::PAD_SPI2_SCK])
-    0: begin
-      spi2_sck_out_x_muxed = spi2_sck_out_x;
-      spi2_sck_oe_x_muxed = spi2_sck_oe_x;
-      spi2_sck_in_x = spi2_sck_in_x_muxed;
-    end
-    1: begin
-      spi2_sck_out_x_muxed = gpio_25_out_x;
-      spi2_sck_oe_x_muxed = gpio_25_oe_x;
-      gpio_25_in_x = spi2_sck_in_x_muxed;
-    end
-    default: begin
-      spi2_sck_out_x_muxed = spi2_sck_out_x;
-      spi2_sck_oe_x_muxed = spi2_sck_oe_x;
-      spi2_sck_in_x = spi2_sck_in_x_muxed;
-    end
-   endcase
-  end
-  always_comb
-  begin
-   spi2_sd_0_in_x=1'b0;
-   gpio_26_in_x=1'b0;
-   unique case(pad_muxes[core_v_mini_mcu_pkg::PAD_SPI2_SD_0])
-    0: begin
-      spi2_sd_0_out_x_muxed = spi2_sd_0_out_x;
-      spi2_sd_0_oe_x_muxed = spi2_sd_0_oe_x;
-      spi2_sd_0_in_x = spi2_sd_0_in_x_muxed;
-    end
-    1: begin
-      spi2_sd_0_out_x_muxed = gpio_26_out_x;
-      spi2_sd_0_oe_x_muxed = gpio_26_oe_x;
-      gpio_26_in_x = spi2_sd_0_in_x_muxed;
-    end
-    default: begin
-      spi2_sd_0_out_x_muxed = spi2_sd_0_out_x;
-      spi2_sd_0_oe_x_muxed = spi2_sd_0_oe_x;
-      spi2_sd_0_in_x = spi2_sd_0_in_x_muxed;
-    end
-   endcase
-  end
-  always_comb
-  begin
-   spi2_sd_1_in_x=1'b0;
-   gpio_27_in_x=1'b0;
-   unique case(pad_muxes[core_v_mini_mcu_pkg::PAD_SPI2_SD_1])
-    0: begin
-      spi2_sd_1_out_x_muxed = spi2_sd_1_out_x;
-      spi2_sd_1_oe_x_muxed = spi2_sd_1_oe_x;
-      spi2_sd_1_in_x = spi2_sd_1_in_x_muxed;
-    end
-    1: begin
-      spi2_sd_1_out_x_muxed = gpio_27_out_x;
-      spi2_sd_1_oe_x_muxed = gpio_27_oe_x;
-      gpio_27_in_x = spi2_sd_1_in_x_muxed;
-    end
-    default: begin
-      spi2_sd_1_out_x_muxed = spi2_sd_1_out_x;
-      spi2_sd_1_oe_x_muxed = spi2_sd_1_oe_x;
-      spi2_sd_1_in_x = spi2_sd_1_in_x_muxed;
-    end
-   endcase
-  end
-  always_comb
-  begin
-   spi2_sd_2_in_x=1'b0;
-   gpio_28_in_x=1'b0;
-   unique case(pad_muxes[core_v_mini_mcu_pkg::PAD_SPI2_SD_2])
-    0: begin
-      spi2_sd_2_out_x_muxed = spi2_sd_2_out_x;
-      spi2_sd_2_oe_x_muxed = spi2_sd_2_oe_x;
-      spi2_sd_2_in_x = spi2_sd_2_in_x_muxed;
-    end
-    1: begin
-      spi2_sd_2_out_x_muxed = gpio_28_out_x;
-      spi2_sd_2_oe_x_muxed = gpio_28_oe_x;
-      gpio_28_in_x = spi2_sd_2_in_x_muxed;
-    end
-    default: begin
-      spi2_sd_2_out_x_muxed = spi2_sd_2_out_x;
-      spi2_sd_2_oe_x_muxed = spi2_sd_2_oe_x;
-      spi2_sd_2_in_x = spi2_sd_2_in_x_muxed;
-    end
-   endcase
-  end
-  always_comb
-  begin
-   spi2_sd_3_in_x=1'b0;
-   gpio_29_in_x=1'b0;
-   unique case(pad_muxes[core_v_mini_mcu_pkg::PAD_SPI2_SD_3])
-    0: begin
-      spi2_sd_3_out_x_muxed = spi2_sd_3_out_x;
-      spi2_sd_3_oe_x_muxed = spi2_sd_3_oe_x;
-      spi2_sd_3_in_x = spi2_sd_3_in_x_muxed;
-    end
-    1: begin
-      spi2_sd_3_out_x_muxed = gpio_29_out_x;
-      spi2_sd_3_oe_x_muxed = gpio_29_oe_x;
-      gpio_29_in_x = spi2_sd_3_in_x_muxed;
-    end
-    default: begin
-      spi2_sd_3_out_x_muxed = spi2_sd_3_out_x;
-      spi2_sd_3_oe_x_muxed = spi2_sd_3_oe_x;
-      spi2_sd_3_in_x = spi2_sd_3_in_x_muxed;
-    end
-   endcase
-  end
-  always_comb
-  begin
-   i2c_scl_in_x=1'b0;
-   gpio_31_in_x=1'b0;
-   unique case(pad_muxes[core_v_mini_mcu_pkg::PAD_I2C_SCL])
-    0: begin
-      i2c_scl_out_x_muxed = i2c_scl_out_x;
-      i2c_scl_oe_x_muxed = i2c_scl_oe_x;
-      i2c_scl_in_x = i2c_scl_in_x_muxed;
-    end
-    1: begin
-      i2c_scl_out_x_muxed = gpio_31_out_x;
-      i2c_scl_oe_x_muxed = gpio_31_oe_x;
-      gpio_31_in_x = i2c_scl_in_x_muxed;
-    end
-    default: begin
-      i2c_scl_out_x_muxed = i2c_scl_out_x;
-      i2c_scl_oe_x_muxed = i2c_scl_oe_x;
-      i2c_scl_in_x = i2c_scl_in_x_muxed;
-    end
-   endcase
-  end
-  always_comb
-  begin
-   i2c_sda_in_x=1'b0;
-   gpio_30_in_x=1'b0;
-   unique case(pad_muxes[core_v_mini_mcu_pkg::PAD_I2C_SDA])
-    0: begin
-      i2c_sda_out_x_muxed = i2c_sda_out_x;
-      i2c_sda_oe_x_muxed = i2c_sda_oe_x;
-      i2c_sda_in_x = i2c_sda_in_x_muxed;
-    end
-    1: begin
-      i2c_sda_out_x_muxed = gpio_30_out_x;
-      i2c_sda_oe_x_muxed = gpio_30_oe_x;
-      gpio_30_in_x = i2c_sda_in_x_muxed;
-    end
-    default: begin
-      i2c_sda_out_x_muxed = i2c_sda_out_x;
-      i2c_sda_oe_x_muxed = i2c_sda_oe_x;
-      i2c_sda_in_x = i2c_sda_in_x_muxed;
-    end
-   endcase
-  end
-
-
-  pad_control #(
-    .reg_req_t(reg_pkg::reg_req_t),
-    .reg_rsp_t(reg_pkg::reg_rsp_t),
-    .NUM_PAD  (core_v_mini_mcu_pkg::NUM_PAD)
-  ) pad_control_i (
-    .clk_i(clk_in_x),
-    .rst_ni(rst_ngen),
-    .reg_req_i(pad_req),
-    .reg_rsp_o(pad_resp),
-    .pad_attributes_o(pad_attributes),
-    .pad_muxes_o(pad_muxes)
-  );
-
-  rstgen rstgen_i (
-    .clk_i(clk_in_x),
-    .rst_ni(rst_n),
-    .test_mode_i(1'b0),
-    .rst_no(rst_ngen),
-    .init_no()
-  );
-
-  assign exit_value_o = exit_value[0];
-endmodule
diff --git a/linux_femu/rtl/linux_femu.sv.tpl b/linux_femu/rtl/linux_femu.sv.tpl
deleted file mode 100644
index 1217cba..0000000
--- a/linux_femu/rtl/linux_femu.sv.tpl
+++ /dev/null
@@ -1,514 +0,0 @@
-// Copyright 2022 EPFL
-// Solderpad Hardware License, Version 2.1, see LICENSE.md for details.
-// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1
-
-module linux_femu
-  import obi_pkg::*;
-  import reg_pkg::*;
-#(
-  parameter PULP_XPULP           = 0,
-  parameter FPU                  = 0,
-  parameter PULP_ZFINX           = 0,
-  parameter EXT_XBAR_NMASTER     = 0,
-  parameter CLK_LED_COUNT_LENGTH = 27
-) (
-  inout logic clk_in,
-  inout logic rst_i,
-
-  output logic rst_led,
-  output logic clk_led,
-  output logic clk_out,
-
-  inout logic boot_select_i,
-  inout logic execute_from_flash_i,
-
-  inout logic [29:0] gpio_io,
-
-  output logic exit_value_o,
-  inout  logic exit_valid_o,
-
-  inout logic spi_sd_0_io,
-  inout logic spi_sd_1_io,
-  inout logic spi_sd_2_io,
-  inout logic spi_sd_3_io,
-  inout logic spi_csb_io,
-  inout logic spi_sck_io,
-
-  inout logic spi2_sd_0_io,
-  inout logic spi2_sd_1_io,
-  inout logic spi2_sd_2_io,
-  inout logic spi2_sd_3_io,
-  inout logic [1:0] spi2_csb_io,
-  inout logic spi2_sck_io,
-
-  inout logic i2c_scl_io,
-  inout logic i2c_sda_io,
-
-  inout wire [14:0] DDR_addr,
-  inout wire [2:0] DDR_ba,
-  inout wire DDR_cas_n,
-  inout wire DDR_ck_n,
-  inout wire DDR_ck_p,
-  inout wire DDR_cke,
-  inout wire DDR_cs_n,
-  inout wire [3:0] DDR_dm,
-  inout wire [31:0] DDR_dq,
-  inout wire [3:0] DDR_dqs_n,
-  inout wire [3:0] DDR_dqs_p,
-  inout wire DDR_odt,
-  inout wire DDR_ras_n,
-  inout wire DDR_reset_n,
-  inout wire DDR_we_n,
-  inout wire FIXED_IO_ddr_vrn,
-  inout wire FIXED_IO_ddr_vrp,
-  inout wire [53:0] FIXED_IO_mio,
-  inout wire FIXED_IO_ps_clk,
-  inout wire FIXED_IO_ps_porb,
-  inout wire FIXED_IO_ps_srstb
-);
-
-  import core_v_mini_mcu_pkg::*;
-
-  parameter AXI_ADDR_WIDTH = 32;
-  parameter AXI_ADDR_WIDTH_SLAVE = 4;
-  parameter AXI_DATA_WIDTH = 32;
-
-  // PM signals
-  logic cpu_subsystem_powergate_switch;
-  logic cpu_subsystem_powergate_switch_ack;
-  logic cpu_subsystem_powergate_iso;
-  logic cpu_subsystem_rst_n;
-  logic peripheral_subsystem_powergate_switch;
-  logic peripheral_subsystem_powergate_switch_ack;
-  logic peripheral_subsystem_powergate_iso;
-  logic peripheral_subsystem_rst_n;
-  logic [core_v_mini_mcu_pkg::NUM_BANKS-1:0] memory_subsystem_banks_powergate_switch;
-  logic [core_v_mini_mcu_pkg::NUM_BANKS-1:0] memory_subsystem_banks_powergate_switch_ack;
-  logic [core_v_mini_mcu_pkg::NUM_BANKS-1:0] memory_subsystem_banks_powergate_iso;
-  logic [core_v_mini_mcu_pkg::NUM_BANKS-1:0] memory_subsystem_banks_set_retentive;
-
-  // PS SIDE PORTS
-  logic AXI_HP_ACLK;
-  logic AXI_HP_ARESETN;
-  logic [AXI_ADDR_WIDTH - 1:0] AXI_HP_araddr_sig;
-  logic [1:0] AXI_HP_arburst_sig;
-  logic [3:0] AXI_HP_arcache_sig;
-  logic [5:0] AXI_HP_arid_sig;
-  logic [3:0] AXI_HP_arlen_sig;
-  logic [1:0] AXI_HP_arlock_sig;
-  logic [2:0] AXI_HP_arprot_sig;
-  logic [3:0] AXI_HP_arqos_sig;
-  logic AXI_HP_arready_sig;
-  logic [2:0] AXI_HP_arsize_sig;
-  logic AXI_HP_arvalid_sig;
-  logic [AXI_ADDR_WIDTH - 1:0] AXI_HP_awaddr_sig;
-  logic [1:0] AXI_HP_awburst_sig;
-  logic [3:0] AXI_HP_awcache_sig;
-  logic [5:0] AXI_HP_awid_sig;
-  logic [3:0] AXI_HP_awlen_sig;
-  logic [1:0] AXI_HP_awlock_sig;
-  logic [2:0] AXI_HP_awprot_sig;
-  logic [3:0] AXI_HP_awqos_sig;
-  logic AXI_HP_awready_sig;
-  logic [2:0] AXI_HP_awsize_sig;
-  logic AXI_HP_awvalid_sig;
-  logic [5:0] AXI_HP_bid_sig;
-  logic AXI_HP_bready_sig;
-  logic [1:0] AXI_HP_bresp_sig;
-  logic AXI_HP_bvalid_sig;
-  logic [AXI_DATA_WIDTH - 1:0] AXI_HP_rdata_sig;
-  logic [5:0] AXI_HP_rid_sig;
-  logic AXI_HP_rlast_sig;
-  logic AXI_HP_rready_sig;
-  logic [1:0] AXI_HP_rresp_sig;
-  logic AXI_HP_rvalid_sig;
-  logic [AXI_DATA_WIDTH - 1:0] AXI_HP_wdata_sig;
-  logic [5:0] AXI_HP_wid_sig;
-  logic AXI_HP_wlast_sig;
-  logic AXI_HP_wready_sig;
-  logic [3:0] AXI_HP_wstrb_sig;
-  logic AXI_HP_wvalid_sig;
-
-  logic spi_test_clk_sig;
-  logic spi_test_cs_sig;
-  logic [3:0] spi_test_data_sig;
-
-  // ADDRESS HIJACKER PORTS
-  logic [AXI_ADDR_WIDTH-1:0] axi_master_awaddr_in_sig;
-  logic [AXI_ADDR_WIDTH-1:0] axi_master_araddr_in_sig;
-
-  logic [AXI_ADDR_WIDTH_SLAVE - 1 : 0] s00_axi_awaddr_sig;
-  logic s00_axi_awvalid_sig;
-  logic s00_axi_awready_sig;
-  logic [AXI_DATA_WIDTH - 1 : 0] s00_axi_wdata_sig;
-  logic s00_axi_wvalid_sig;
-  logic s00_axi_wready_sig;
-  logic s00_axi_bvalid_sig;
-  logic s00_axi_bready_sig;
-  logic [(AXI_DATA_WIDTH / 8)-1 : 0] s00_axi_wstrb_sig;
-  logic [2 : 0] s00_axi_arprot_sig;
-  logic [2 : 0] s00_axi_awprot_sig;
-  logic [AXI_ADDR_WIDTH_SLAVE - 1 : 0] s00_axi_araddr_sig;
-  logic s00_axi_arvalid_sig;
-  logic s00_axi_arready_sig;
-  logic [AXI_DATA_WIDTH - 1 : 0] s00_axi_rdata_sig;
-  logic s00_axi_rvalid_sig;
-  logic s00_axi_rready_sig;
-  logic [1:0] s00_axi_rresp_sig;
-  logic [1:0] s00_axi_bresp_sig;
-
-  // PAD controller
-  reg_req_t pad_req;
-  reg_rsp_t pad_resp;
-  logic [core_v_mini_mcu_pkg::NUM_PAD-1:0][7:0] pad_attributes;
-  logic [core_v_mini_mcu_pkg::NUM_PAD-1:0][3:0] pad_muxes;
-
-  logic rst_ngen;
-
-  // input, output pins from core_v_mini_mcu
-% for pad in total_pad_list:
-${pad.internal_signals}
-% endfor
-
-  wire                               clk_gen;
-  logic [                      31:0] exit_value;
-  wire                               rst_n;
-  logic [CLK_LED_COUNT_LENGTH - 1:0] clk_count;
-
-  // low active reset
-  assign rst_n   = !rst_i;
-
-  // reset LED for debugging
-  assign rst_led = rst_n;
-
-  // counter to blink an LED
-  assign clk_led = clk_count[CLK_LED_COUNT_LENGTH-1];
-
-  always_ff @(posedge clk_gen or negedge rst_n) begin : clk_count_process
-    if (!rst_n) begin
-      clk_count <= '0;
-    end else begin
-      clk_count <= clk_count + 1;
-    end
-  end
-
-  // clock output for debugging
-  assign clk_out = clk_gen;
-
-  xilinx_clk_wizard_wrapper xilinx_clk_wizard_wrapper_i (
-    .clk_125MHz(clk_in),
-    .clk_out1_0(clk_gen)
-  );
-
-  logic clk_i;
-  assign clk_i = clk_gen;
-
-  core_v_mini_mcu #(
-    .PULP_XPULP(PULP_XPULP),
-    .FPU(FPU),
-    .PULP_ZFINX(PULP_ZFINX),
-    .EXT_XBAR_NMASTER(EXT_XBAR_NMASTER)
-  ) core_v_mini_mcu_i (
-
-    .rst_ni(rst_ngen),
-% for pad in pad_list:
-${pad.core_v_mini_mcu_bonding}
-% endfor
-    .intr_vector_ext_i('0),
-    .ext_xbar_master_req_i('0),
-    .ext_xbar_master_resp_o(),
-    .ext_xbar_slave_req_o(),
-    .ext_xbar_slave_resp_i('0),
-    .ext_peripheral_slave_req_o(),
-    .ext_peripheral_slave_resp_i('0),
-    .external_subsystem_powergate_switch_o(),
-    .external_subsystem_powergate_switch_ack_i(),
-    .external_subsystem_powergate_iso_o(),
-    .external_subsystem_rst_no(),
-    .external_ram_banks_set_retentive_o(),
-    .exit_value_o(exit_value),
-    .pad_req_o(pad_req),
-    .pad_resp_i(pad_resp),
-    .cpu_subsystem_powergate_switch_o(cpu_subsystem_powergate_switch),
-    .cpu_subsystem_powergate_switch_ack_i(cpu_subsystem_powergate_switch_ack),
-    .peripheral_subsystem_powergate_switch_o(peripheral_subsystem_powergate_switch),
-    .peripheral_subsystem_powergate_switch_ack_i(peripheral_subsystem_powergate_switch_ack),
-    .memory_subsystem_banks_powergate_switch_o(memory_subsystem_banks_powergate_switch),
-    .memory_subsystem_banks_powergate_switch_ack_i(memory_subsystem_banks_powergate_switch_ack)
-  );
-
-  logic gpio_0_io;
-  logic gpio_1_io;
-  logic gpio_2_io;
-  logic gpio_3_io;
-  logic gpio_4_io;
-  logic gpio_5_io;
-  logic gpio_6_io;
-  logic gpio_7_io;
-  logic gpio_8_io;
-  logic gpio_9_io;
-  logic gpio_10_io;
-  logic gpio_11_io;
-  logic gpio_12_io;
-  logic gpio_13_io;
-  logic gpio_14_io;
-  logic gpio_15_io;
-  logic gpio_16_io;
-  logic gpio_17_io;
-  logic gpio_18_io;
-  logic gpio_19_io;
-  logic gpio_20_io;
-  logic gpio_21_io;
-  logic gpio_22_io;
-
-  assign spi_flash_sck_o_sig = spi_flash_sck_out_x;
-  assign spi_flash_csb_o_sig = spi_flash_cs_0_out_x;
-  assign spi_sdi1_sig = spi_flash_sd_1_in_x;
-  assign spi_sdo0_sig = spi_flash_sd_0_out_x;
-  assign spi_sdo2_sig = spi_sd_2_out_x;
-  assign spi_sdo3_sig = spi_sd_3_out_x;
-
-  assign spi2_csb_io[0] = spi2_cs_0_io;
-  assign spi2_csb_io[1] = spi2_cs_1_io;
-
-  assign gpio_io[0] = gpio_0_io;
-  assign gpio_io[1] = gpio_1_io;
-  assign gpio_io[2] = gpio_2_io;
-  assign gpio_io[3] = gpio_3_io;
-  assign gpio_io[4] = gpio_4_io;
-  assign gpio_io[5] = gpio_5_io;
-  assign gpio_io[6] = gpio_6_io;
-  assign gpio_io[7] = gpio_7_io;
-  assign gpio_io[8] = gpio_8_io;
-  assign gpio_io[9] = gpio_9_io;
-  assign gpio_io[10] = gpio_10_io;
-  assign gpio_io[11] = gpio_11_io;
-  assign gpio_io[12] = gpio_12_io;
-  assign gpio_io[13] = gpio_13_io;
-  assign gpio_io[14] = gpio_14_io;
-  assign gpio_io[15] = gpio_15_io;
-  assign gpio_io[16] = gpio_16_io;
-  assign gpio_io[17] = gpio_17_io;
-  assign gpio_io[18] = gpio_18_io;
-  assign gpio_io[19] = gpio_19_io;
-  assign gpio_io[20] = gpio_20_io;
-  assign gpio_io[21] = gpio_21_io;
-  assign gpio_io[22] = gpio_22_io;
-
-  processing_system_wrapper processing_system_wrapper_i (
-    .DDR_addr(DDR_addr),
-    .DDR_ba(DDR_ba),
-    .DDR_cas_n(DDR_cas_n),
-    .DDR_ck_n(DDR_ck_n),
-    .DDR_ck_p(DDR_ck_p),
-    .DDR_cke(DDR_cke),
-    .DDR_cs_n(DDR_cs_n),
-    .DDR_dm(DDR_dm),
-    .DDR_dq(DDR_dq),
-    .DDR_dqs_n(DDR_dqs_n),
-    .DDR_dqs_p(DDR_dqs_p),
-    .DDR_odt(DDR_odt),
-    .DDR_ras_n(DDR_ras_n),
-    .DDR_reset_n(DDR_reset_n),
-    .DDR_we_n(DDR_we_n),
-    .FIXED_IO_ddr_vrn(FIXED_IO_ddr_vrn),
-    .FIXED_IO_ddr_vrp(FIXED_IO_ddr_vrp),
-    .FIXED_IO_mio(FIXED_IO_mio),
-    .FIXED_IO_ps_clk(FIXED_IO_ps_clk),
-    .FIXED_IO_ps_porb(FIXED_IO_ps_porb),
-    .FIXED_IO_ps_srstb(FIXED_IO_ps_srstb),
-    .UART_rxd(uart_tx_out_x),
-    .UART_txd(uart_rx_in_x),
-    .gpio_jtag_tck_i(jtag_tck_in_x),
-    .gpio_jtag_tms_i(jtag_tms_in_x),
-    .gpio_jtag_trst_ni(jtag_trst_nin_x),
-    .gpio_jtag_tdi_i(jtag_tdi_in_x),
-    .gpio_jtag_tdo_o(jtag_tdo_out_x),
-    .AXI_HP_ACLK(AXI_HP_ACLK),
-    .AXI_HP_ARESETN(AXI_HP_ARESETN),
-    .AXI_HP_araddr(AXI_HP_araddr_sig),
-    .AXI_HP_arburst(AXI_HP_arburst_sig),
-    .AXI_HP_arcache(AXI_HP_arcache_sig),
-    .AXI_HP_arlen(AXI_HP_arlen_sig),
-    .AXI_HP_arlock(AXI_HP_arlock_sig),
-    .AXI_HP_arprot(AXI_HP_arprot_sig),
-    .AXI_HP_arqos(AXI_HP_arqos_sig),
-    .AXI_HP_arready(AXI_HP_arready_sig),
-    .AXI_HP_arsize(AXI_HP_arsize_sig),
-    .AXI_HP_arvalid(AXI_HP_arvalid_sig),
-    .AXI_HP_awaddr(AXI_HP_awaddr_sig),
-    .AXI_HP_awburst(AXI_HP_awburst_sig),
-    .AXI_HP_awcache(AXI_HP_awcache_sig),
-    .AXI_HP_awlen(AXI_HP_awlen_sig),
-    .AXI_HP_awlock(AXI_HP_awlock_sig),
-    .AXI_HP_awprot(AXI_HP_awprot_sig),
-    .AXI_HP_awqos(AXI_HP_awqos_sig),
-    .AXI_HP_awready(AXI_HP_awready_sig),
-    .AXI_HP_awsize(AXI_HP_awsize_sig),
-    .AXI_HP_awvalid(AXI_HP_awvalid_sig),
-    .AXI_HP_bready(AXI_HP_bready_sig),
-    .AXI_HP_bresp(AXI_HP_bresp_sig),
-    .AXI_HP_bvalid(AXI_HP_bvalid_sig),
-    .AXI_HP_rdata(AXI_HP_rdata_sig),
-    .AXI_HP_rlast(AXI_HP_rlast_sig),
-    .AXI_HP_rready(AXI_HP_rready_sig),
-    .AXI_HP_rresp(AXI_HP_rresp_sig),
-    .AXI_HP_rvalid(AXI_HP_rvalid_sig),
-    .AXI_HP_wdata(AXI_HP_wdata_sig),
-    .AXI_HP_wlast(AXI_HP_wlast_sig),
-    .AXI_HP_wready(AXI_HP_wready_sig),
-    .AXI_HP_wstrb(AXI_HP_wstrb_sig),
-    .AXI_HP_wvalid(AXI_HP_wvalid_sig),
-    .M_AXI_araddr(s00_axi_araddr_sig),
-    .M_AXI_arready(s00_axi_arready_sig),
-    .M_AXI_arvalid(s00_axi_arvalid_sig),
-    .M_AXI_awaddr(s00_axi_awaddr_sig),
-    .M_AXI_awready(s00_axi_awready_sig),
-    .M_AXI_awvalid(s00_axi_awvalid_sig),
-    .M_AXI_bready(s00_axi_bready_sig),
-    .M_AXI_bresp(s00_axi_bresp_sig),
-    .M_AXI_bvalid(s00_axi_bvalid_sig),
-    .M_AXI_rdata(s00_axi_rdata_sig),
-    .M_AXI_rready(s00_axi_rready_sig),
-    .M_AXI_rresp(s00_axi_rresp_sig),
-    .M_AXI_rvalid(s00_axi_rvalid_sig),
-    .M_AXI_wdata(s00_axi_wdata_sig),
-    .M_AXI_wready(s00_axi_wready_sig),
-    .M_AXI_wvalid(s00_axi_wvalid_sig),
-    .M_AXI_awprot(s00_axi_awprot_sig),
-    .M_AXI_arprot(s00_axi_arprot_sig),
-    .M_AXI_wstrb(s00_axi_wstrb_sig)
-  );
-
-  axi_address_hijacker #(
-    .AXI_ADDR_WIDTH(AXI_ADDR_WIDTH),
-    .C_S_AXI_DATA_WIDTH(AXI_DATA_WIDTH)
-  ) add_hij (
-    .axi_master_awaddr_in(axi_master_awaddr_in_sig),
-    .axi_master_araddr_in(axi_master_araddr_in_sig),
-
-    // output write and read address by adding fixed offset
-    .axi_master_araddr_out(AXI_HP_araddr_sig),
-    .axi_master_awaddr_out(AXI_HP_awaddr_sig),
-
-    .S_AXI_ACLK(AXI_HP_ACLK),
-    .S_AXI_ARESETN(AXI_HP_ARESETN),
-
-    .S_AXI_AWADDR (s00_axi_awaddr_sig),
-    .S_AXI_AWPROT (s00_axi_awprot_sig),
-    .S_AXI_AWVALID(s00_axi_awvalid_sig),
-    .S_AXI_AWREADY(s00_axi_awready_sig),
-    .S_AXI_WDATA  (s00_axi_wdata_sig),
-    .S_AXI_WSTRB  (s00_axi_wstrb_sig),
-    .S_AXI_WVALID (s00_axi_wvalid_sig),
-    .S_AXI_WREADY (s00_axi_wready_sig),
-    .S_AXI_BRESP  (s00_axi_bresp_sig),
-    .S_AXI_BVALID (s00_axi_bvalid_sig),
-    .S_AXI_BREADY (s00_axi_bready_sig),
-    .S_AXI_ARADDR (s00_axi_araddr_sig),
-    .S_AXI_ARPROT (s00_axi_arprot_sig),
-    .S_AXI_ARVALID(s00_axi_arvalid_sig),
-    .S_AXI_ARREADY(s00_axi_arready_sig),
-    .S_AXI_RDATA  (s00_axi_rdata_sig),
-    .S_AXI_RRESP  (s00_axi_rresp_sig),
-    .S_AXI_RVALID (s00_axi_rvalid_sig),
-    .S_AXI_RREADY (s00_axi_rready_sig)
-  );
-
-  axi_spi_slave #(
-    .AXI_DATA_WIDTH(AXI_DATA_WIDTH)
-  ) fake_flash (
-    .axi_aclk(AXI_HP_ACLK),
-    .axi_aresetn(AXI_HP_ARESETN),
-
-    .test_mode('0),
-
-    .axi_master_aw_valid(AXI_HP_awvalid_sig),
-    .axi_master_aw_id(AXI_HP_awid_sig),
-    .axi_master_aw_prot(AXI_HP_awprot_sig),
-    .axi_master_aw_qos(AXI_HP_awqos_sig),
-    .axi_master_aw_cache(AXI_HP_awcache_sig),
-    .axi_master_aw_lock(AXI_HP_awlock_sig),
-    .axi_master_aw_burst(AXI_HP_awburst_sig),
-    .axi_master_aw_size(AXI_HP_awsize_sig),
-    .axi_master_aw_len(AXI_HP_awlen_sig),
-    .axi_master_aw_addr(axi_master_awaddr_in_sig),
-    .axi_master_aw_ready(AXI_HP_awready_sig),
-
-    .axi_master_w_valid(AXI_HP_wvalid_sig),
-    .axi_master_w_data (AXI_HP_wdata_sig),
-    .axi_master_w_strb (AXI_HP_wstrb_sig),
-    .axi_master_w_last (AXI_HP_wlast_sig),
-    .axi_master_w_ready(AXI_HP_wready_sig),
-
-    .axi_master_b_valid(AXI_HP_bvalid_sig),
-    .axi_master_b_id(AXI_HP_bid_sig),
-    .axi_master_b_resp(AXI_HP_bresp_sig),
-    .axi_master_b_ready(AXI_HP_bready_sig),
-
-    .axi_master_ar_valid(AXI_HP_arvalid_sig),
-    .axi_master_ar_id(AXI_HP_arid_sig),
-    .axi_master_ar_prot(AXI_HP_arprot_sig),
-    .axi_master_ar_qos(AXI_HP_arqos_sig),
-    .axi_master_ar_cache(AXI_HP_arcache_sig),
-    .axi_master_ar_lock(AXI_HP_arlock_sig),
-    .axi_master_ar_burst(AXI_HP_arburst_sig),
-    .axi_master_ar_size(AXI_HP_arsize_sig),
-    .axi_master_ar_len(AXI_HP_arlen_sig),
-    .axi_master_ar_addr(axi_master_araddr_in_sig),
-    .axi_master_ar_ready(AXI_HP_arready_sig),
-
-    .axi_master_r_valid(AXI_HP_rvalid_sig),
-    .axi_master_r_id(AXI_HP_rid_sig),
-    .axi_master_r_data(AXI_HP_rdata_sig),
-    .axi_master_r_resp(AXI_HP_rresp_sig),
-    .axi_master_r_last(AXI_HP_rlast_sig),
-    .axi_master_r_ready(AXI_HP_rready_sig),
-
-    .spi_sclk(spi_flash_sck_o_sig),
-    .spi_cs  (spi_flash_csb_o_sig),
-    .spi_sdo1(spi_sdi1_sig),
-    .spi_sdi0(spi_sdo0_sig),
-    .spi_sdi2(spi_sdo2_sig),
-    .spi_sdi3(spi_sdo3_sig)
-  );
-
-  // TESTING PURPOSES -> THEY WILL BE INPUT TO PS AND READ BY SYSTEM ILA
-  assign spi_test_clk_sig  = spi_flash_sck_o_sig;
-  assign spi_test_cs_sig   = spi_flash_csb_o_sig;
-  assign spi_test_data_sig = {spi_sdo0_sig, spi_sdi1_sig, spi_sdo2_sig, spi_sdo3_sig};
-
-  pad_ring pad_ring_i (
-% for pad in total_pad_list:
-${pad.pad_ring_bonding_bonding}
-% endfor
-    .pad_attributes_i(pad_attributes)
-  );
-
-${pad_constant_driver_assign}
-
-${pad_mux_process}
-
-  pad_control #(
-    .reg_req_t(reg_pkg::reg_req_t),
-    .reg_rsp_t(reg_pkg::reg_rsp_t),
-    .NUM_PAD  (core_v_mini_mcu_pkg::NUM_PAD)
-  ) pad_control_i (
-    .clk_i(clk_in_x),
-    .rst_ni(rst_ngen),
-    .reg_req_i(pad_req),
-    .reg_rsp_o(pad_resp),
-    .pad_attributes_o(pad_attributes),
-    .pad_muxes_o(pad_muxes)
-  );
-
-  rstgen rstgen_i (
-    .clk_i(clk_in_x),
-    .rst_ni(rst_n),
-    .test_mode_i(1'b0),
-    .rst_no(rst_ngen),
-    .init_no()
-  );
-
-  assign exit_value_o = exit_value[0];
-endmodule
diff --git a/linux_femu/scripts/xilinx_generate_processing_system.tcl b/linux_femu/scripts/xilinx_generate_processing_system.tcl
deleted file mode 100644
index a4628c5..0000000
--- a/linux_femu/scripts/xilinx_generate_processing_system.tcl
+++ /dev/null
@@ -1,118 +0,0 @@
-# Copyright 2022 EPFL
-# Solderpad Hardware License, Version 2.1, see LICENSE.md for details.
-# SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1
-# Define design macros
-
-# Select board
-set_property board_part tul.com.tw:pynq-z2:part0:1.0 [current_project]
-
-# Create block design
-create_bd_design "processing_system"
-
-# Add Zynq Processing System
-create_bd_cell -type ip -vlnv xilinx.com:ip:processing_system7:5.5 processing_system7_0
-apply_bd_automation -rule xilinx.com:bd_rule:processing_system7 -config {make_external "FIXED_IO, DDR" apply_board_preset "1" Master "Disable" Slave "Disable" }  [get_bd_cells processing_system7_0]
-set_property -dict [list CONFIG.PCW_FPGA0_PERIPHERAL_FREQMHZ {20} CONFIG.PCW_USE_S_AXI_HP0 {1} CONFIG.PCW_QSPI_GRP_SINGLE_SS_ENABLE {1} CONFIG.PCW_ENET0_PERIPHERAL_ENABLE {0} CONFIG.PCW_SD0_PERIPHERAL_ENABLE {0} CONFIG.PCW_UART0_PERIPHERAL_ENABLE {0} CONFIG.PCW_UART1_PERIPHERAL_ENABLE {1} CONFIG.PCW_UART1_UART1_IO {EMIO} CONFIG.PCW_USB0_PERIPHERAL_ENABLE {0} CONFIG.PCW_GPIO_MIO_GPIO_ENABLE {0} CONFIG.PCW_GPIO_EMIO_GPIO_ENABLE {1} CONFIG.PCW_GPIO_EMIO_GPIO_IO {5}] [get_bd_cells processing_system7_0]
-
-# Add AXI Interconnect
-create_bd_cell -type ip -vlnv xilinx.com:ip:axi_interconnect:2.1 axi_interconnect_0
-set_property -dict [list CONFIG.NUM_SI {2} CONFIG.NUM_MI {2}] [get_bd_cells axi_interconnect_0]
-
-# Add Constant
-create_bd_cell -type ip -vlnv xilinx.com:ip:xlconstant:1.1 xlconstant_0
-set_property -dict [list CONFIG.CONST_WIDTH {2} CONFIG.CONST_VAL {0b11}] [get_bd_cells xlconstant_0]
-
-# Add Concatenation
-create_bd_cell -type ip -vlnv xilinx.com:ip:xlconcat:2.1 xlconcat_0
-set_property -dict [list CONFIG.IN0_WIDTH.VALUE_SRC USER CONFIG.IN1_WIDTH.VALUE_SRC USER CONFIG.IN2_WIDTH.VALUE_SRC USER] [get_bd_cells xlconcat_0]
-set_property -dict [list CONFIG.NUM_PORTS {3} CONFIG.IN0_WIDTH {2} CONFIG.IN2_WIDTH {2}] [get_bd_cells xlconcat_0]
-
-# Add Slices
-create_bd_cell -type ip -vlnv xilinx.com:ip:xlslice:1.0 xlslice_0
-create_bd_cell -type ip -vlnv xilinx.com:ip:xlslice:1.0 xlslice_1
-create_bd_cell -type ip -vlnv xilinx.com:ip:xlslice:1.0 xlslice_2
-create_bd_cell -type ip -vlnv xilinx.com:ip:xlslice:1.0 xlslice_3
-set_property -dict [list CONFIG.DIN_TO {3} CONFIG.DIN_FROM {3} CONFIG.DIN_WIDTH {5} CONFIG.DOUT_WIDTH {1}] [get_bd_cells xlslice_0]
-set_property -dict [list CONFIG.DIN_TO {4} CONFIG.DIN_FROM {4} CONFIG.DIN_WIDTH {5} CONFIG.DOUT_WIDTH {1}] [get_bd_cells xlslice_1]
-set_property -dict [list CONFIG.DIN_TO {1} CONFIG.DIN_FROM {1} CONFIG.DIN_WIDTH {5} CONFIG.DOUT_WIDTH {1}] [get_bd_cells xlslice_2]
-set_property -dict [list CONFIG.DIN_TO {0} CONFIG.DIN_FROM {0} CONFIG.DIN_WIDTH {5} CONFIG.DOUT_WIDTH {1}] [get_bd_cells xlslice_3]
-
-# Create port AXI_HP
-make_bd_intf_pins_external [get_bd_intf_pins axi_interconnect_0/S00_AXI]
-set_property name AXI_HP [get_bd_intf_ports S00_AXI_0]
-set_property -dict [list CONFIG.FREQ_HZ {20000000}] [get_bd_intf_ports AXI_HP]
-
-# Create port M_AXI
-make_bd_intf_pins_external  [get_bd_intf_pins axi_interconnect_0/M01_AXI]
-set_property name M_AXI [get_bd_intf_ports M01_AXI_0]
-set_property -dict [list CONFIG.FREQ_HZ {20000000}] [get_bd_intf_ports M_AXI]
-
-# Connect AXI Interconnect and Zynq Processing System
-connect_bd_intf_net -boundary_type upper [get_bd_intf_pins axi_interconnect_0/M00_AXI] [get_bd_intf_pins processing_system7_0/S_AXI_HP0]
-connect_bd_intf_net [get_bd_intf_pins processing_system7_0/M_AXI_GP0] -boundary_type upper [get_bd_intf_pins axi_interconnect_0/S01_AXI]
-apply_bd_automation -rule xilinx.com:bd_rule:clkrst -config { Clk {/processing_system7_0/FCLK_CLK0 (20 MHz)} Freq {100} Ref_Clk0 {} Ref_Clk1 {} Ref_Clk2 {}} [get_bd_pins axi_interconnect_0/ACLK]
-apply_bd_automation -rule xilinx.com:bd_rule:clkrst -config { Clk {/processing_system7_0/FCLK_CLK0 (20 MHz)} Freq {100} Ref_Clk0 {} Ref_Clk1 {} Ref_Clk2 {}} [get_bd_pins axi_interconnect_0/M00_ACLK]
-apply_bd_automation -rule xilinx.com:bd_rule:clkrst -config { Clk {/processing_system7_0/FCLK_CLK0 (20 MHz)} Freq {100} Ref_Clk0 {} Ref_Clk1 {} Ref_Clk2 {}} [get_bd_pins axi_interconnect_0/M01_ACLK]
-apply_bd_automation -rule xilinx.com:bd_rule:clkrst -config { Clk {/processing_system7_0/FCLK_CLK0 (20 MHz)} Freq {100} Ref_Clk0 {} Ref_Clk1 {} Ref_Clk2 {}} [get_bd_pins axi_interconnect_0/S00_ACLK]
-apply_bd_automation -rule xilinx.com:bd_rule:clkrst -config { Clk {/processing_system7_0/FCLK_CLK0 (20 MHz)} Freq {100} Ref_Clk0 {} Ref_Clk1 {} Ref_Clk2 {}} [get_bd_pins axi_interconnect_0/S01_ACLK]
-
-# Create port AXI_HP_ACLK
-create_bd_port -dir O -type clk AXI_HP_ACLK
-
-# Create port AXI_HP_ARESETN
-create_bd_port -dir O -type rst AXI_HP_ARESETN
-
-# Connect AXI_HP_ACLK and AXI_HP_ARESETN
-connect_bd_net [get_bd_ports AXI_HP_ACLK] [get_bd_pins processing_system7_0/FCLK_CLK0]
-connect_bd_net [get_bd_ports AXI_HP_ARESETN] [get_bd_pins rst_ps7_0_20M/peripheral_aresetn]
-
-# Create port gpio_jtag_tdo_o
-make_bd_pins_external [get_bd_pins xlconcat_0/In1]
-set_property name gpio_jtag_tdo_o [get_bd_ports In1_0]
-
-# Connect Constant and Concatenation
-connect_bd_net [get_bd_pins xlconstant_0/dout] [get_bd_pins xlconcat_0/In0]
-connect_bd_net [get_bd_pins xlconcat_0/In2] [get_bd_pins xlconstant_0/dout]
-connect_bd_net [get_bd_pins xlconcat_0/dout] [get_bd_pins processing_system7_0/GPIO_I]
-
-# Create port gpio_jtag_tdi_i
-make_bd_pins_external [get_bd_pins xlslice_0/Dout]
-set_property name gpio_jtag_tdi_i [get_bd_ports Dout_0]
-
-# Create port gpio_jtag_tck_i
-make_bd_pins_external [get_bd_pins xlslice_1/Dout]
-set_property name gpio_jtag_tck_i [get_bd_ports Dout_0]
-
-# Create port gpio_jtag_tms_i
-make_bd_pins_external [get_bd_pins xlslice_2/Dout]
-set_property name gpio_jtag_tms_i [get_bd_ports Dout_0]
-
-# Create port gpio_jtag_trst_ni
-make_bd_pins_external [get_bd_pins xlslice_3/Dout]
-set_property name gpio_jtag_trst_ni [get_bd_ports Dout_0]
-
-# Connect Slices
-connect_bd_net [get_bd_pins xlslice_0/Din] [get_bd_pins processing_system7_0/GPIO_O]
-connect_bd_net [get_bd_pins xlslice_1/Din] [get_bd_pins processing_system7_0/GPIO_O]
-connect_bd_net [get_bd_pins xlslice_2/Din] [get_bd_pins processing_system7_0/GPIO_O]
-connect_bd_net [get_bd_pins xlslice_3/Din] [get_bd_pins processing_system7_0/GPIO_O]
-
-# Create port UART
-make_bd_intf_pins_external [get_bd_intf_pins processing_system7_0/UART_1]
-set_property name UART [get_bd_intf_ports UART_1_0]
-
-# Assign addresses
-assign_bd_address
-
-# Validate design
-validate_bd_design
-
-# Save design
-save_bd_design
-
-# Close design
-close_bd_design [get_bd_designs processing_system]
-
-# Make wrapper
-set wrapper_path [ make_wrapper -fileset sources_1 -files [ get_files -norecurse processing_system.bd ] -top ]
-add_files -norecurse -fileset sources_1 $wrapper_path
